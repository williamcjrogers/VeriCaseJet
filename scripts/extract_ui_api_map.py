"""Extract a best-effort UI→API usage map for VeriCaseJet.

This scans `vericase/ui/` (HTML + JS) for `/api/...` strings.
It produces a markdown report that helps keep user-facing docs grounded in
real UI behavior.

Notes:
- This is static text scanning. It cannot infer request methods reliably.
- Some endpoints may be assembled dynamically (e.g., `${base}/api/...`).
"""

from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parents[1]
UI_ROOT = REPO_ROOT / "vericase" / "ui"
OUT_MD = REPO_ROOT / "docs" / "UI_API_MAP.md"

# Keep scan small/fast.
SCAN_SUFFIXES = {".html", ".js"}
# Note: we *do* want to scan `assets/js/*` because key UI logic lives there
# (e.g., correspondence SSRM grid + AI panel). We only skip styling folders.
SKIP_DIRS = {"styles"}

# Capture API paths that start with /api/ and stop at a quote/whitespace/)
API_RE = re.compile(r"/api/[A-Za-z0-9_\-./{}]+")


@dataclass
class FileHit:
    rel_path: str
    endpoints: list[str]


def iter_ui_files(root: Path) -> list[Path]:
    files: list[Path] = []
    for p in root.rglob("*"):
        if p.is_dir():
            continue
        if p.suffix.lower() not in SCAN_SUFFIXES:
            continue
        if any(part in SKIP_DIRS for part in p.relative_to(root).parts):
            continue
        # Avoid scanning huge bundled files if any exist.
        try:
            if p.stat().st_size > 600_000:
                continue
        except OSError:
            continue
        files.append(p)
    return sorted(files)


def read_text(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""


def normalize_endpoint(ep: str) -> str:
    # strip trailing punctuation that sometimes attaches in JS
    return ep.rstrip("'\"`);,>")


def main() -> int:
    if not UI_ROOT.exists():
        raise SystemExit(f"UI root not found: {UI_ROOT}")

    hits: list[FileHit] = []
    all_eps: set[str] = set()

    for f in iter_ui_files(UI_ROOT):
        txt = read_text(f)
        eps = sorted({normalize_endpoint(m.group(0)) for m in API_RE.finditer(txt)})
        if eps:
            rel = str(f.relative_to(REPO_ROOT)).replace("\\", "/")
            hits.append(FileHit(rel_path=rel, endpoints=eps))
            all_eps.update(eps)

    OUT_MD.parent.mkdir(parents=True, exist_ok=True)

    lines: list[str] = []
    lines.append("# UI → API Map (best-effort)\n")
    lines.append(
        "This file is generated by `scripts/extract_ui_api_map.py`. It is a static scan of the UI for `/api/...` strings.\n"
    )
    lines.append("## Summary\n")
    lines.append(f"- UI root: `{UI_ROOT.relative_to(REPO_ROOT)}`")
    lines.append(f"- Files scanned: {len(iter_ui_files(UI_ROOT))}")
    lines.append(f"- Files with API references: {len(hits)}")
    lines.append(f"- Unique `/api` paths found: {len(all_eps)}\n")

    lines.append("## API paths (unique)\n")
    for ep in sorted(all_eps):
        lines.append(f"- `{ep}`")

    lines.append("\n## By UI file\n")
    for h in hits:
        lines.append(f"### `{h.rel_path}`\n")
        for ep in h.endpoints:
            lines.append(f"- `{ep}`")
        lines.append("")

    OUT_MD.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")

    print(f"Wrote {OUT_MD}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
