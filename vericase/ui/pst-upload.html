<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VeriCase - Upload Evidence (v1.1)</title>
  <link rel="stylesheet" href="./assets/fontawesome/css/all.min.css" />
  <link rel="stylesheet" href="assets/global.css" />
  <link rel="stylesheet" href="brand-styles.css?v=10" />
  <link rel="stylesheet" href="design-system.css?v=10" />
  <script src="vericase-ui.js"></script>
  <script src="nav-shell.js"></script>
  <script src="security.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family:
        "Segoe UI",
        -apple-system,
        BlinkMacSystemFont,
        Roboto,
        sans-serif;
      background: var(--bg-primary);
      min-height: 100vh;
      color: var(--text-primary);
    }

    .top-bar {
      background: white;
      backdrop-filter: blur(20px);
      color: var(--vericase-navy);
      padding: 12px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--gray-200);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .app-shell .top-bar {
      display: none;
    }

    .top-bar h1 {
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
    }

    .top-bar h1 img {
      height: 28px;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-ghost {
      background: transparent;
      color: #a0a0c0;
      border: 1px solid rgba(160, 160, 192, 0.3);
    }

    .btn-ghost:hover {
      background: rgba(var(--vericase-teal-rgb), 0.1);
      color: var(--vericase-navy);
      border-color: rgba(var(--vericase-teal-rgb), 0.5);
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 30px 20px;
    }

    /* ============================================
       TOAST NOTIFICATION SYSTEM
       ============================================ */
    .toast-container {
      position: fixed;
      top: 24px;
      right: 24px;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }

    .toast {
      background: white;
      border-radius: 12px;
      padding: 16px 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
      display: flex;
      align-items: center;
      gap: 14px;
      min-width: 320px;
      max-width: 420px;
      pointer-events: auto;
      animation: toastSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      transform-origin: right center;
    }

    .toast.hiding {
      animation: toastSlideOut 0.3s ease-in forwards;
    }

    @keyframes toastSlideIn {
      from { transform: translateX(120%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes toastSlideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(120%); opacity: 0; }
    }

    .toast-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
    }

    .toast.success .toast-icon {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    .toast.info .toast-icon {
      background: linear-gradient(135deg, var(--vericase-teal), var(--vericase-navy));
      color: white;
    }

    .toast.warning .toast-icon {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }

    .toast.error .toast-icon {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    .toast-content {
      flex: 1;
    }

    .toast-title {
      font-weight: 600;
      font-size: 14px;
      color: var(--vericase-navy);
      margin-bottom: 2px;
    }

    .toast-message {
      font-size: 12px;
      color: var(--text-muted);
    }

    .toast-close {
      background: none;
      border: none;
      color: #a0a0c0;
      cursor: pointer;
      padding: 4px;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .toast-close:hover {
      background: var(--gray-100);
      color: var(--vericase-navy);
    }

    .toast-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--gray-200);
      border-radius: 0 0 12px 12px;
      overflow: hidden;
    }

    .toast-progress-fill {
      height: 100%;
      background: var(--vericase-teal);
      animation: toastProgress 4s linear forwards;
    }

    @keyframes toastProgress {
      from { width: 100%; }
      to { width: 0%; }
    }

    /* ============================================
       ANIMATED STATS BAR
       ============================================ */
    .stats-bar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .stat-card {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 12px;
      padding: 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--vericase-teal), transparent);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .stat-card.active::before {
      opacity: 1;
      animation: statShimmer 2s infinite;
    }

    /* Spin the Uploading stat icon while uploads/processing are active */
    .stat-card.active .stat-icon.orange i {
      animation: spin 1s linear infinite;
    }

    @keyframes statShimmer {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .stat-card.highlight {
      transform: scale(1.02);
      border-color: var(--vericase-teal);
      box-shadow: 0 8px 24px rgba(var(--vericase-teal-rgb), 0.2);
    }

    .stat-icon {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: white;
      position: relative;
    }

    .stat-icon.blue {
      background: linear-gradient(135deg, var(--vericase-teal), var(--vericase-navy));
    }

    .stat-icon.green {
      background: linear-gradient(135deg, #10b981, #059669);
    }

    .stat-icon.orange {
      background: linear-gradient(135deg, #f59e0b, #d97706);
    }

    .stat-icon.red {
      background: linear-gradient(135deg, #ef4444, #dc2626);
    }

    .stat-icon .spin-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .stat-icon.loading .spin-overlay {
      opacity: 1;
    }

    .stat-icon.loading .spin-overlay i {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .stat-info h3 {
      font-size: 24px;
      font-weight: 700;
      color: var(--vericase-navy);
      font-variant-numeric: tabular-nums;
      transition: all 0.3s;
    }

    .stat-info h3.counting {
      color: var(--vericase-teal);
    }

    .stat-info p {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    /* ============================================
       UPLOAD SECTION
       ============================================ */
    .upload-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }

    @media (max-width: 1024px) {
      .upload-section {
        grid-template-columns: 1fr;
      }
    }

    .upload-card {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    }

    .upload-card h2 {
      font-size: 18px;
      margin-bottom: 16px;
      color: var(--vericase-navy);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .upload-zone {
      border: 2px dashed rgba(var(--vericase-teal-rgb), 0.5);
      border-radius: 12px;
      padding: 48px 24px;
      text-align: center;
      background: rgba(var(--vericase-teal-rgb), 0.05);
      transition: all 0.3s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .upload-zone::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: radial-gradient(circle, rgba(var(--vericase-teal-rgb), 0.15), transparent 70%);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.5s ease;
      pointer-events: none;
    }

    .upload-zone:hover::before {
      width: 300px;
      height: 300px;
    }

    .upload-zone:hover {
      background: rgba(var(--vericase-teal-rgb), 0.1);
      border-color: rgba(var(--vericase-teal-rgb), 0.8);
    }

    .upload-zone.dragover {
      background: rgba(var(--vericase-teal-rgb), 0.15);
      border-color: var(--vericase-teal);
      transform: scale(1.01);
    }

    .upload-zone.dragover::before {
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, rgba(var(--vericase-teal-rgb), 0.25), transparent 70%);
    }

    .upload-zone.uploading {
      pointer-events: none;
      opacity: 0.7;
    }

    .upload-zone i {
      font-size: 48px;
      color: var(--vericase-teal);
      margin-bottom: 16px;
      position: relative;
      z-index: 1;
    }

    .upload-zone h3 {
      font-size: 18px;
      color: var(--vericase-navy);
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }

    .upload-zone p {
      color: var(--text-muted);
      font-size: 14px;
      margin-bottom: 16px;
      position: relative;
      z-index: 1;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--vericase-teal) 0%, var(--vericase-navy) 100%);
      color: white;
      border: none;
      position: relative;
      z-index: 1;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(var(--vericase-teal-rgb), 0.4);
    }

    .file-types {
      display: flex;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 20px;
      position: relative;
      z-index: 1;
    }

    .file-type-badge {
      background: rgba(var(--vericase-teal-rgb), 0.2);
      padding: 6px 14px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      color: var(--vericase-teal);
      border: 1px solid rgba(var(--vericase-teal-rgb), 0.3);
    }
    .whatsapp-badge {
      color: #25d366;
      font-weight: 600;
    }

    /* ============================================
       ENHANCED FILE QUEUE
       ============================================ */
    .queue-card {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 16px;
      max-height: 500px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    }

    .queue-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .queue-header h2 {
      font-size: 16px;
      color: var(--vericase-navy);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .queue-actions {
      display: flex;
      gap: 8px;
    }

    .btn-sm {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 6px;
    }

    .btn-success {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    .btn-danger {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .btn-danger:hover {
      background: #ef4444;
      color: white;
    }

    .queue-list {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .queue-empty {
      text-align: center;
      padding: 48px 24px;
      color: #606080;
    }

    .queue-empty i {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    /* Enhanced File Items */
    .file-item {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .file-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--gray-300);
      transition: all 0.3s;
    }

    .file-item:hover {
      border-color: rgba(var(--vericase-teal-rgb), 0.3);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .file-item.uploading {
      border-color: rgba(var(--vericase-teal-rgb), 0.5);
      background: linear-gradient(90deg, rgba(var(--vericase-teal-rgb), 0.05), white);
    }

    .file-item.uploading::before {
      background: linear-gradient(180deg, var(--vericase-teal), var(--vericase-navy));
      animation: uploadPulse 1.5s ease-in-out infinite;
    }

    @keyframes uploadPulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .file-item.queued {
      border-color: rgba(245, 158, 11, 0.35);
      background: linear-gradient(90deg, rgba(245, 158, 11, 0.03), white);
    }

    .file-item.queued::before {
      background: linear-gradient(180deg, #fbbf24, #f59e0b);
    }

    .file-item.processing {
      border-color: rgba(245, 158, 11, 0.5);
      background: linear-gradient(90deg, rgba(245, 158, 11, 0.05), white);
    }

    .file-item.processing::before {
      background: linear-gradient(180deg, #f59e0b, #d97706);
    }

    .file-item.complete {
      border-color: rgba(16, 185, 129, 0.5);
      background: linear-gradient(90deg, rgba(16, 185, 129, 0.05), white);
    }

    .file-item.complete::before {
      background: linear-gradient(180deg, #10b981, #059669);
    }

    .file-item.error {
      border-color: rgba(239, 68, 68, 0.5);
      background: linear-gradient(90deg, rgba(239, 68, 68, 0.05), white);
    }

    .file-item.error::before {
      background: linear-gradient(180deg, #ef4444, #dc2626);
    }

    .file-item-row {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .file-icon {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      flex-shrink: 0;
      position: relative;
    }

    .file-icon.pst {
      background: linear-gradient(135deg, var(--vericase-teal), var(--vericase-navy));
      color: white;
    }

    .file-icon.eml {
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: white;
    }

    .file-icon.msg {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed);
      color: white;
    }

    .file-icon.pdf {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    .file-icon.doc {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
    }

    .file-icon.xls {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    .file-icon.default {
      background: rgba(100, 100, 140, 0.5);
      color: #a0a0c0;
    }

    .file-details {
      flex: 1;
      min-width: 0;
    }

    .file-details h4 {
      font-size: 14px;
      color: var(--vericase-navy);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 4px;
      font-weight: 600;
    }

    .file-meta {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .file-meta span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .file-progress-section {
      width: 140px;
      flex-shrink: 0;
    }

    .file-progress {
      width: 100%;
    }

    .progress-bar {
      height: 8px;
      background: var(--gray-200);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 6px;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--vericase-teal), var(--vericase-navy));
      transition: width 0.3s ease;
      border-radius: 4px;
      position: relative;
    }

    .progress-fill.indeterminate {
      width: 100%;
      background: linear-gradient(
        90deg,
        rgba(var(--vericase-teal-rgb), 0.15),
        rgba(var(--vericase-teal-rgb), 0.7),
        rgba(var(--vericase-teal-rgb), 0.15)
      );
      background-size: 200% 100%;
      animation: progressIndeterminate 1.5s ease-in-out infinite;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: progressShimmer 1.5s infinite;
    }

    .progress-fill.indeterminate::after {
      display: none;
    }

    @keyframes progressShimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    @keyframes progressIndeterminate {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .progress-fill.complete {
      background: linear-gradient(90deg, #10b981, #059669);
    }

    .progress-fill.complete::after {
      display: none;
    }

    .progress-fill.error {
      background: linear-gradient(90deg, #ef4444, #dc2626);
    }

    .progress-fill.error::after {
      display: none;
    }

    .progress-info {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      color: var(--text-muted);
    }

    .progress-percent {
      font-weight: 600;
      color: var(--vericase-teal);
    }

    .progress-speed {
      font-family: 'SF Mono', Monaco, monospace;
    }

    .file-status-badge {
      font-size: 11px;
      padding: 5px 12px;
      border-radius: 20px;
      font-weight: 600;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 5px;
    }

    .file-status-badge.pending {
      background: var(--gray-100);
      color: var(--text-muted);
    }

    .file-status-badge.uploading {
      background: rgba(var(--vericase-teal-rgb), 0.15);
      color: var(--vericase-teal);
    }

    .file-status-badge.uploading i {
      animation: spin 1s linear infinite;
    }

    .file-status-badge.processing {
      background: rgba(245, 158, 11, 0.15);
      color: #f59e0b;
    }

    .file-status-badge.processing i {
      animation: spin 1.5s linear infinite;
    }

    .file-status-badge.queued {
      background: rgba(245, 158, 11, 0.10);
      color: #d97706;
    }

    .file-status-badge.complete {
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }

    .file-status-badge.error {
      background: rgba(239, 68, 68, 0.15);
      color: #ef4444;
    }

    .file-remove {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: none;
      background: transparent;
      color: #606080;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .file-remove:hover {
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
    }

    /* Chunk Progress for Large Files */
    .chunk-progress {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px dashed var(--gray-200);
    }

    .chunk-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .chunk-grid {
      display: flex;
      gap: 3px;
      flex-wrap: wrap;
    }

    .chunk-block {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      background: var(--gray-200);
      transition: all 0.3s ease;
    }

    .chunk-block.uploading {
      background: var(--vericase-teal);
      animation: chunkPulse 0.8s ease-in-out infinite;
    }

    .chunk-block.complete {
      background: #10b981;
    }

    .chunk-block.error {
      background: #ef4444;
    }

    @keyframes chunkPulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.1); }
    }

    /* ============================================
       HISTORY SECTION
       ============================================ */
    .history-card {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    }

    .history-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .history-header h2 {
      font-size: 16px;
      color: var(--vericase-navy);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .history-table {
      width: 100%;
      border-collapse: collapse;
    }

    .history-table th,
    .history-table td {
      padding: 14px 16px;
      text-align: left;
      border-bottom: 1px solid var(--gray-200);
    }

    .history-table th {
      background: var(--gray-100);
      font-weight: 600;
      color: var(--text-muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .history-table tr {
      transition: background 0.2s;
    }

    .history-table tr:hover {
      background: rgba(var(--vericase-teal-rgb), 0.05);
    }

    .history-filename {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 500;
      color: var(--vericase-navy);
    }

    .history-filename i {
      color: var(--vericase-teal);
    }

    .email-count {
      display: flex;
      flex-direction: column;
    }

    .email-count .processed {
      color: #10b981;
      font-weight: 600;
    }

    .email-count .total {
      color: #606080;
      font-size: 11px;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
    }

    .status-pending {
      background: rgba(245, 158, 11, 0.2);
      color: #f59e0b;
    }

    .status-processing {
      background: rgba(59, 130, 246, 0.2);
      color: #3b82f6;
    }

    /* Ensure the Processing badge spinner actually spins (don't rely on FontAwesome animation helpers) */
    .status-badge.status-processing i {
      animation: spin 1s linear infinite;
    }

    .status-completed {
      background: rgba(16, 185, 129, 0.2);
      color: #10b981;
    }

    .status-failed {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .history-actions {
      display: flex;
      gap: 6px;
    }

    .btn-icon {
      width: 32px;
      height: 32px;
      border-radius: 6px;
      border: 1px solid rgba(var(--vericase-teal-rgb), 0.3);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .btn-icon:hover {
      background: rgba(var(--vericase-teal-rgb), 0.2);
      color: var(--vericase-teal);
      border-color: rgba(var(--vericase-teal-rgb), 0.5);
    }

    .btn-icon.btn-danger {
      border-color: rgba(239, 68, 68, 0.35);
      color: #ef4444;
    }

    .btn-icon.btn-danger:hover {
      background: rgba(239, 68, 68, 0.12);
      border-color: rgba(239, 68, 68, 0.6);
      color: #ef4444;
    }

    .no-history {
      text-align: center;
      padding: 60px 24px;
      color: #606080;
    }

    .no-history i {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    /* ============================================
       ENHANCED GLOBAL PROGRESS PANEL
       ============================================ */
    .global-progress {
      position: fixed;
      bottom: 24px;
      right: 24px;
      background: white;
      backdrop-filter: blur(20px);
      border: 1px solid var(--gray-200);
      border-radius: 20px;
      padding: 24px;
      width: 380px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.1);
      display: none;
      z-index: 1000;
      overflow: hidden;
    }

    .global-progress::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--vericase-teal), var(--vericase-navy), var(--vericase-teal));
      background-size: 200% 100%;
      animation: gradientShift 2s linear infinite;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 0%; }
      100% { background-position: 200% 0%; }
    }

    .global-progress.active {
      display: block;
      animation: panelSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes panelSlideIn {
      from { transform: translateY(40px) scale(0.95); opacity: 0; }
      to { transform: translateY(0) scale(1); opacity: 1; }
    }

    .global-progress-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .global-progress h3 {
      font-size: 16px;
      color: var(--vericase-navy);
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
    }

    .global-progress h3 i {
      color: var(--vericase-teal);
      animation: bounce 1s ease infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }

    .global-progress .minimize-btn {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 6px;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .global-progress .minimize-btn:hover {
      background: var(--gray-100);
    }

    .global-stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .global-stat {
      text-align: center;
      padding: 12px 8px;
      background: var(--gray-50);
      border-radius: 10px;
      transition: all 0.3s;
    }

    .global-stat.active {
      background: rgba(var(--vericase-teal-rgb), 0.1);
      border: 1px solid rgba(var(--vericase-teal-rgb), 0.2);
    }

    .global-stat .number {
      font-size: 20px;
      font-weight: 700;
      color: var(--vericase-navy);
      font-variant-numeric: tabular-nums;
    }

    .global-stat .label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-top: 2px;
    }

    .global-bar-container {
      margin-bottom: 16px;
    }

    .global-bar-label {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .global-bar-label .phase {
      color: var(--vericase-navy);
      font-weight: 500;
    }

    .global-bar-label .eta {
      color: var(--text-muted);
    }

    .global-bar {
      height: 10px;
      background: var(--gray-200);
      border-radius: 5px;
      overflow: hidden;
      position: relative;
    }

    .global-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--vericase-teal), var(--vericase-navy));
      transition: width 0.4s ease;
      border-radius: 5px;
      position: relative;
    }

    .global-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: progressShimmer 1.5s infinite;
    }

    .global-current-file {
      background: var(--gray-50);
      border-radius: 10px;
      padding: 12px 14px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .global-current-file .file-icon-mini {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--vericase-teal), var(--vericase-navy));
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .global-current-file .file-info {
      flex: 1;
      min-width: 0;
    }

    .global-current-file .file-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--vericase-navy);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .global-current-file .file-status {
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .global-current-file .file-status .speed {
      color: var(--vericase-teal);
      font-weight: 500;
    }

    /* ============================================
       ENHANCED LIVE PROCESSING TRACKER
       ============================================ */
    .live-tracker {
      background: linear-gradient(135deg, rgba(var(--vericase-teal-rgb), 0.03), rgba(26, 35, 66, 0.02));
      border: 1px solid rgba(var(--vericase-teal-rgb), 0.2);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 4px 20px rgba(var(--vericase-teal-rgb), 0.08);
      display: none;
      position: relative;
      overflow: hidden;
    }

    .live-tracker::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--vericase-teal), transparent);
      animation: trackerPulse 3s ease-in-out infinite;
    }

    @keyframes trackerPulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .live-tracker.active {
      display: block;
      animation: trackerFadeIn 0.5s ease;
    }

    @keyframes trackerFadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .live-tracker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .live-tracker-header h2 {
      font-size: 18px;
      color: var(--vericase-navy);
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 0;
    }

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
      color: #10b981;
      background: rgba(16, 185, 129, 0.1);
      padding: 6px 12px;
      border-radius: 20px;
    }

    .live-indicator .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #10b981;
      animation: livePulse 1.5s ease-in-out infinite;
    }

    @keyframes livePulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.3); opacity: 0.6; }
    }

    .processing-items {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .processing-item {
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: 16px;
      padding: 20px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .processing-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, var(--vericase-teal), var(--vericase-navy));
    }

    .processing-item:hover {
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      transform: translateY(-2px);
    }

    .processing-item-main {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .processing-item-icon {
      width: 52px;
      height: 52px;
      border-radius: 14px;
      background: linear-gradient(135deg, var(--vericase-teal), var(--vericase-navy));
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      position: relative;
    }

    .processing-item-icon .spinner-ring {
      position: absolute;
      inset: -4px;
      border: 2px solid transparent;
      border-top-color: var(--vericase-teal);
      border-radius: 50%;
      animation: spinRing 1.2s linear infinite;
    }

    @keyframes spinRing {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .processing-item-details {
      flex: 1;
    }

    .processing-item-details h4 {
      font-size: 15px;
      color: var(--vericase-navy);
      margin-bottom: 6px;
      font-weight: 600;
    }

    .processing-item-stats {
      display: flex;
      gap: 20px;
      font-size: 13px;
      color: var(--text-muted);
    }

    .processing-item-stats span {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .processing-item-stats strong {
      color: var(--vericase-teal);
      font-weight: 600;
    }

    .processing-item-progress {
      width: 160px;
      flex-shrink: 0;
    }

    .processing-item-progress .progress-bar {
      height: 10px;
      background: var(--gray-200);
      border-radius: 5px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .processing-item-progress .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--vericase-teal), var(--vericase-navy));
      transition: width 0.5s ease;
      border-radius: 5px;
    }

    .processing-item-progress .progress-text {
      font-size: 12px;
      color: var(--vericase-navy);
      text-align: center;
      font-weight: 600;
    }

    /* Phase Indicator */
    .phase-indicator {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px dashed var(--gray-200);
      display: flex;
      justify-content: space-between;
    }

    .phase-step {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      flex: 1;
      position: relative;
    }

    .phase-step:not(:last-child)::after {
      content: '';
      position: absolute;
      top: 14px;
      left: 50%;
      width: 100%;
      height: 2px;
      background: var(--gray-200);
      z-index: 0;
    }

    .phase-step.complete:not(:last-child)::after {
      background: var(--vericase-teal);
    }

    .phase-step .phase-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--gray-200);
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      position: relative;
      z-index: 1;
      transition: all 0.3s;
    }

    .phase-step.complete .phase-icon {
      background: var(--vericase-teal);
      color: white;
    }

    .phase-step.active .phase-icon {
      background: linear-gradient(135deg, var(--vericase-teal), var(--vericase-navy));
      color: white;
      animation: phaseActive 1s ease-in-out infinite;
    }

    @keyframes phaseActive {
      0%, 100% { box-shadow: 0 0 0 0 rgba(var(--vericase-teal-rgb), 0.4); }
      50% { box-shadow: 0 0 0 8px rgba(var(--vericase-teal-rgb), 0); }
    }

    .phase-step .phase-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .phase-step.active .phase-label,
    .phase-step.complete .phase-label {
      color: var(--vericase-teal);
      font-weight: 600;
    }

    /* ============================================
       SCROLLBAR
       ============================================ */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--gray-100);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(var(--vericase-teal-rgb), 0.3);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(var(--vericase-teal-rgb), 0.5);
    }
  </style>
  <script src="config.js"></script>
  <script src="app-state.js"></script>
</head>

<body>
  <!-- Toast Notifications Container -->
  <div class="toast-container" id="toastContainer"></div>

  <div class="top-bar">
    <h1>
      <img src="/ui/assets/LOGOTOBEUSED.png" alt="VeriCase" />
      <i class="fas fa-cloud-upload-alt" style="color: var(--vericase-teal)"></i>
      Evidence Upload <span style="font-size: 12px; opacity: 0.7; margin-left: 10px;">v1.1</span>
    </h1>
	    <button class="btn btn-ghost" onclick="goToDashboard()" style="
	          background: white;
	          color: var(--vericase-navy);
	          border: 2px solid var(--gray-200);
	        ">
	      <i class="fas fa-arrow-left"></i> Back to Overview
	    </button>
	  </div>

  <div class="container">
    <!-- Live Processing Tracker -->
    <div class="live-tracker" id="liveTracker">
      <div class="live-tracker-header">
        <h2>
          <i class="fas fa-cogs" style="color: var(--vericase-teal);"></i>
          Live Processing Status
        </h2>
        <div style="display: flex; align-items: center; gap: 12px;">
          <div class="live-indicator">
            <span class="dot"></span>
            LIVE
          </div>
          <button class="btn btn-sm btn-ghost" onclick="refreshLiveStatus()">
            <i class="fas fa-sync-alt"></i> Refresh
          </button>
        </div>
      </div>
      <div class="processing-items" id="processingItems">
        <!-- Dynamically populated -->
      </div>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar">
      <div class="stat-card">
        <div class="stat-icon blue"><i class="fas fa-file-alt"></i></div>
        <div class="stat-info">
          <h3 id="statTotal">0</h3>
          <p>Files Selected</p>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-icon green"><i class="fas fa-check-circle"></i></div>
        <div class="stat-info">
          <h3 id="statComplete">0</h3>
          <p>Completed</p>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-icon orange"><i class="fas fa-spinner"></i></div>
        <div class="stat-info">
          <h3 id="statProcessing">0</h3>
          <p>Uploading</p>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-icon red">
          <i class="fas fa-exclamation-triangle"></i>
        </div>
        <div class="stat-info">
          <h3 id="statErrors">0</h3>
          <p>Errors</p>
        </div>
      </div>
    </div>

    <!-- Upload Section -->
    <div class="upload-section">
      <div class="upload-card">
        <h2><i class="fas fa-upload"></i> Add Files</h2>
        <div class="upload-zone" id="uploadZone">
          <i class="fas fa-cloud-upload-alt"></i>
          <h3>Drag & drop files here</h3>
          <p>or click to browse your computer</p>
          <button class="btn btn-primary">
            <i class="fas fa-folder-open"></i> Select Files
          </button>
          <div class="file-types">
            <span class="file-type-badge">.PST</span>
            <span class="file-type-badge">.EML</span>
            <span class="file-type-badge">.MSG</span>
            <span class="file-type-badge">.PDF</span>
            <span class="file-type-badge">.TXT</span>
            <span class="file-type-badge">.ZIP</span>
            <span class="file-type-badge">.DOCX</span>
            <span class="file-type-badge">.XLSX</span>
          </div>
        </div>
        <input type="file" id="fileInput" multiple accept=".pst,.eml,.msg,.pdf,.docx,.doc,.xlsx,.xls,.csv,.txt,.zip"
          style="display: none" />
      </div>

      <div class="queue-card">
        <div class="queue-header">
          <h2>
            <i class="fas fa-list"></i> Upload Queue
            <span id="queueCount">(0)</span>
          </h2>
          <div class="queue-actions">
            <button class="btn btn-sm btn-danger" onclick="clearQueue()" id="btnClear" disabled>
              <i class="fas fa-trash"></i> Clear
            </button>
            <button class="btn btn-sm btn-success" onclick="startUpload()" id="btnUpload" disabled>
              <i class="fas fa-play"></i> Upload All
            </button>
          </div>
        </div>
        <div class="queue-list" id="queueList">
          <div class="queue-empty">
            <i class="fas fa-inbox"></i>
            <p>No files in queue</p>
            <p style="font-size: 12px; margin-top: 8px">
              Drop files or click above to add
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- Upload History -->
    <div class="history-card">
      <div class="history-header">
        <h2><i class="fas fa-history"></i> Recent Uploads</h2>
        <button class="btn btn-sm btn-ghost" onclick="loadPSTHistory()">
          <i class="fas fa-sync-alt"></i> Refresh
        </button>
      </div>
      <div id="historyContent">
        <div class="no-history">
          <i class="fas fa-spinner fa-spin"></i>
          <p>Loading history...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Global Progress Overlay -->
  <div class="global-progress" id="globalProgress">
    <div class="global-progress-header">
      <h3><i class="fas fa-cloud-upload-alt"></i> Uploading Files</h3>
    </div>
    <div class="global-stats">
      <div class="global-stat" id="gpCompleteStat">
        <div class="number" id="gpComplete">0</div>
        <div class="label">Complete</div>
      </div>
      <div class="global-stat" id="gpUploadingStat">
        <div class="number" id="gpUploading">0</div>
        <div class="label">Uploading</div>
      </div>
      <div class="global-stat" id="gpTotalStat">
        <div class="number" id="gpTotal">0</div>
        <div class="label">Total</div>
      </div>
      <div class="global-stat" id="gpSpeedStat">
        <div class="number" id="gpSpeed">--</div>
        <div class="label">Speed</div>
      </div>
    </div>
    <div class="global-bar-container">
      <div class="global-bar-label">
        <span class="phase" id="gpPhase">Preparing upload...</span>
        <span class="eta" id="gpEta"></span>
      </div>
      <div class="global-bar">
        <div class="global-fill" id="gpFill" style="width: 0"></div>
      </div>
    </div>
    <div class="global-current-file" id="gpCurrentFile" style="display: none;">
      <div class="file-icon-mini">
        <i class="fas fa-file" id="gpFileIcon"></i>
      </div>
      <div class="file-info">
        <div class="file-name" id="gpFileName">--</div>
        <div class="file-status">
          <span id="gpFileProgress">0%</span>
          <span class="speed" id="gpFileSpeed">--</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const apiUrl = window.VeriCaseConfig
      ? window.VeriCaseConfig.apiUrl
      : window.location.origin;
    console.log("Upload using API URL:", apiUrl);

    // ============================================
    // TOAST NOTIFICATION SYSTEM
    // ============================================
    const ToastManager = {
      container: null,
      init() {
        this.container = document.getElementById('toastContainer');
      },
      show(type, title, message, duration = 4000) {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `
          <div class="toast-icon">
            <i class="fas ${this.getIcon(type)}"></i>
          </div>
          <div class="toast-content">
            <div class="toast-title">${escapeHtml(title)}</div>
            <div class="toast-message">${escapeHtml(message)}</div>
          </div>
          <button class="toast-close" onclick="this.closest('.toast').remove()">
            <i class="fas fa-times"></i>
          </button>
          <div class="toast-progress">
            <div class="toast-progress-fill" style="animation-duration: ${duration}ms"></div>
          </div>
        `;
        this.container.appendChild(toast);
        
        setTimeout(() => {
          toast.classList.add('hiding');
          setTimeout(() => toast.remove(), 300);
        }, duration);
        
        return toast;
      },
      getIcon(type) {
        return {
          success: 'fa-check',
          info: 'fa-info',
          warning: 'fa-exclamation',
          error: 'fa-times'
        }[type] || 'fa-info';
      },
      success(title, message) { return this.show('success', title, message); },
      info(title, message) { return this.show('info', title, message, 5000); },
      warning(title, message) { return this.show('warning', title, message, 6000); },
      error(title, message) { return this.show('error', title, message, 8000); }
    };

    // ============================================
    // ANIMATED COUNTER
    // ============================================
    function animateCounter(element, targetValue, duration = 500) {
      const startValue = parseInt(element.textContent) || 0;
      const startTime = performance.now();
      
      element.classList.add('counting');
      
      function update(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease out cubic
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        const currentValue = Math.round(startValue + (targetValue - startValue) * easeProgress);
        
        element.textContent = currentValue;
        
        if (progress < 1) {
          requestAnimationFrame(update);
        } else {
          element.classList.remove('counting');
        }
      }
      
      requestAnimationFrame(update);
    }

    // Attach auth token/cookies to API calls that require authentication
    function withAuth(options = {}) {
      const token =
        localStorage.getItem("vericase_token") ||
        localStorage.getItem("token") ||
        localStorage.getItem("jwt") ||
        localStorage.getItem("access_token");
      const csrfToken =
        typeof getCsrfToken === "function" ? getCsrfToken() : null;
      return {
        credentials: "include",
        ...options,
        headers: {
          ...(options.headers || {}),
          ...(token ? { Authorization: `Bearer ${token}` } : {}),
          ...(csrfToken ? { "X-CSRF-Token": csrfToken } : {}),
        },
      };
    }

    // Inject shared navigation shell so this page matches the rest of the app
    if (window.VericaseShell && typeof window.VericaseShell.inject === "function") {
      const ctx =
        typeof window.VericaseShell.getContext === "function"
          ? window.VericaseShell.getContext()
          : { type: "project", id: window.VericaseShell.getProjectId() };
	      const ctxType = ctx?.type === "case" ? "case" : "project";
	      const ctxLabel =
	        ctxType === "case" ? "Case Overview" : "Project Overview";
	      const ctxIcon = ctxType === "case" ? "fa-briefcase" : "fa-diagram-project";
	      const ctxId = ctx?.id ? String(ctx.id) : "";
	      const ctxUrl = ctxId
	        ? `projectdashboard.html?${ctxType === "case" ? "caseId" : "projectId"}=${encodeURIComponent(ctxId)}`
	        : "projectdashboard.html";

	      window.VericaseShell.inject({
	        title: '',
	        breadcrumbs: [
	          { label: "Control Centre", url: "control-centre.html", icon: "fa-compass" },
	          { label: "Workspaces", url: "workspace-hub.html", icon: "fa-layer-group" },
	          { label: ctxLabel, url: ctxUrl, icon: ctxIcon },
	          { label: "Evidence Upload", icon: "fa-upload" },
	        ],
	      });
	    }

    // Retry helper for network issues (optimized for large file uploads)
    async function fetchWithRetry(url, options, retries = 3) {
      for (let i = 0; i < retries; i++) {
        try {
          const controller = new AbortController();
          // Extended timeout for large chunks (100MB can take time on slower connections)
          const timeout = setTimeout(() => controller.abort(), 600000); // 10 min timeout for 100MB chunks

          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });
          clearTimeout(timeout);

          if (response.ok) return response;
          if (response.status >= 500 && i < retries - 1) {
            // Exponential backoff for server errors
            await new Promise((r) => setTimeout(r, 2000 * (i + 1)));
            continue;
          }
          return response;
        } catch (error) {
          if (i === retries - 1) throw error;
          // Longer retry delay for large uploads
          await new Promise((r) => setTimeout(r, 3000 * (i + 1)));
        }
      }
    }

    // State
    let fileQueue = [];
    let isUploading = false;
    let uploadStats = { total: 0, complete: 0, errors: 0, uploading: 0 };
    let uploadStartTime = null;
    let totalBytesUploaded = 0;
    const pstProcessingMonitors = new Map(); // pst_file_id -> intervalId

    function formatExtractedEmailCount(processed, total) {
      const processedNum = Number(processed || 0);
      const totalNum = Number(total || 0);
      if (totalNum > 0) {
        return `Extracted: ${processedNum.toLocaleString()} / ${totalNum.toLocaleString()} emails`;
      }
      return `Extracted: ${processedNum.toLocaleString()} emails`;
    }

    function stopPstProcessingMonitor(pstFileId) {
      const intervalId = pstProcessingMonitors.get(pstFileId);
      if (intervalId) {
        clearInterval(intervalId);
        pstProcessingMonitors.delete(pstFileId);
      }
    }

    function startPstProcessingMonitor(itemId, pstFileId) {
      if (!pstFileId) return;
      if (pstProcessingMonitors.has(pstFileId)) return;

      const poll = async () => {
        const item = fileQueue.find((f) => f.id === itemId);
        if (!item) {
          stopPstProcessingMonitor(pstFileId);
          return;
        }

        try {
          const statusResp = await fetch(
            `${apiUrl}/api/correspondence/pst/${pstFileId}/status`,
            withAuth({}),
          );
          if (!statusResp.ok) return;

          const status = await statusResp.json();
          const processedEmails = Number(status.processed_emails || 0);
          const totalEmails = Number(status.total_emails || 0);
          const statusText = String(status.status || "").toLowerCase();
          const queuedLike =
            statusText === "pending" || statusText === "queued" || statusText === "uploaded";

          const updates = {
            pst_file_id: pstFileId,
            processed_emails: processedEmails,
            total_emails: totalEmails,
          };

          if (statusText === "completed") {
            updates.status = "complete";
            updates.progress = 100;
            stopPstProcessingMonitor(pstFileId);
          } else if (statusText === "failed") {
            updates.status = "error";
            updates.error = status.error_message || "PST processing failed";
            updates.progress = 100;
            stopPstProcessingMonitor(pstFileId);
          } else {
            // Distinguish "queued/pending" from active extraction.
            updates.status = queuedLike ? "queued" : "processing";
            // If the backend can provide a determinate % (pre-count enabled), reflect it,
            // but never move the bar backwards (upload progress may already be 100).
            const pct = Number(status.progress_percent || 0);
            const currentProgress = Number(item.progress || 0);
            if (totalEmails > 0 && pct > 0) {
              const candidate = Math.max(1, Math.min(99, Math.round(pct)));
              if (candidate > currentProgress) {
                updates.progress = candidate;
              }
            } else if (processedEmails > 0 && currentProgress < 99) {
              // Indeterminate (no total) but we've started extracting.
              updates.progress = 99;
            }
          }

          updateFileItem(itemId, updates);
        } catch (e) {
          // Best-effort polling; ignore transient failures.
        }
      };

      poll();
      const intervalId = setInterval(poll, 5000);
      pstProcessingMonitors.set(pstFileId, intervalId);
    }

    // Concurrent upload settings
    const MAX_CONCURRENT = 4; // Max parallel file uploads
    const CHUNK_SIZE = 100 * 1024 * 1024; // 100MB chunks (optimal for 20GB+ files)

    // DOM Elements
    const uploadZone = document.getElementById("uploadZone");
    const fileInput = document.getElementById("fileInput");
    const queueList = document.getElementById("queueList");
    const queueCount = document.getElementById("queueCount");
    const btnUpload = document.getElementById("btnUpload");
    const btnClear = document.getElementById("btnClear");
    const globalProgress = document.getElementById("globalProgress");
    const historyContent = document.getElementById("historyContent");

    // Event Listeners
    uploadZone.addEventListener(
      "click",
      () => !isUploading && fileInput.click(),
    );

    uploadZone.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (!isUploading) uploadZone.classList.add("dragover");
    });

    uploadZone.addEventListener("dragleave", () => {
      uploadZone.classList.remove("dragover");
    });

    uploadZone.addEventListener("drop", (e) => {
      e.preventDefault();
      uploadZone.classList.remove("dragover");
      if (!isUploading) addFiles(e.dataTransfer.files);
    });

    fileInput.addEventListener("change", (e) => {
      addFiles(e.target.files);
      fileInput.value = ""; // Reset so same files can be selected again
    });

    historyContent?.addEventListener("click", (e) => {
      const button = e.target.closest("button[data-action]");
      if (!button) return;
      const action = button.dataset.action;
      const id = button.dataset.id;
      if (!id) return;
      if (action === "process") processPST(id);
      else if (action === "status") checkStatus(id);
      else if (action === "rescue") rescuePST(id);
      else if (action === "error") showPSTError(id);
      else if (action === "view") viewEmails();
      else if (action === "delete") deletePSTUpload(id);
    });

    // Add files to queue
    function addFiles(files) {
      const newFiles = Array.from(files).map((file) => ({
        id: `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        file: file,
        name: file.name,
        size: file.size,
        type: getFileType(file.name),
        status: "pending",
        progress: 0,
        error: null,
        note: null,
        speed: null,
        uploadStartTime: null,
        pst_file_id: null,
        processed_emails: 0,
        total_emails: 0,
      }));

      fileQueue.push(...newFiles);
      updateStats();
      renderQueue();
      
      // Show toast for added files
      const totalSize = newFiles.reduce((sum, f) => sum + f.size, 0);
      ToastManager.info(
        `${newFiles.length} file${newFiles.length > 1 ? 's' : ''} added`,
        `Total size: ${formatSize(totalSize)}`
      );
    }

    function getFileType(filename) {
      const ext = filename.split(".").pop().toLowerCase();
      return ext;
    }

    function isWhatsAppCandidate(item) {
      return (
        (item.type === "txt" || item.type === "zip") &&
        /whatsapp/i.test(item.name || "")
      );
    }

    function getFileIconClass(type) {
      const typeMap = {
        pst: "pst",
        eml: "eml",
        msg: "msg",
        pdf: "pdf",
        doc: "doc",
        docx: "doc",
        xls: "xls",
        xlsx: "xls",
        csv: "xls",
      };
      return typeMap[type] || "default";
    }

    function getFileIcon(type) {
      const iconMap = {
        pst: "fa-envelope",
        eml: "fa-envelope-open",
        msg: "fa-envelope",
        pdf: "fa-file-pdf",
        doc: "fa-file-word",
        docx: "fa-file-word",
        xls: "fa-file-excel",
        xlsx: "fa-file-excel",
        csv: "fa-file-csv",
        txt: "fa-file-alt",
        zip: "fa-file-archive",
      };
      return iconMap[type] || "fa-file";
    }

    function formatSize(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;
    }

    function updateStats() {
      const prevComplete = uploadStats.complete;
      
      uploadStats.total = fileQueue.length;
      uploadStats.complete = fileQueue.filter(
        (f) => f.status === "complete",
      ).length;
      uploadStats.errors = fileQueue.filter(
        (f) => f.status === "error",
      ).length;
      uploadStats.uploading = fileQueue.filter(
        (f) =>
          f.status === "uploading" ||
          f.status === "processing" ||
          f.status === "queued",
      ).length;

      // Animate stat counters
      const statTotal = document.getElementById("statTotal");
      const statComplete = document.getElementById("statComplete");
      const statProcessing = document.getElementById("statProcessing");
      const statErrors = document.getElementById("statErrors");
      
      animateCounter(statTotal, uploadStats.total);
      animateCounter(statComplete, uploadStats.complete);
      animateCounter(statProcessing, uploadStats.uploading);
      animateCounter(statErrors, uploadStats.errors);

      // Highlight active stat cards
      document.querySelectorAll('.stat-card').forEach((card, i) => {
        card.classList.remove('active', 'highlight');
      });
      
      if (uploadStats.uploading > 0) {
        document.querySelectorAll('.stat-card')[2]?.classList.add('active');
      }
      if (uploadStats.complete > prevComplete) {
        document.querySelectorAll('.stat-card')[1]?.classList.add('highlight');
        setTimeout(() => {
          document.querySelectorAll('.stat-card')[1]?.classList.remove('highlight');
        }, 1000);
      }

      queueCount.textContent = `(${uploadStats.total})`;

      const hasFiles = fileQueue.length > 0;
      const hasPending = fileQueue.some((f) => f.status === "pending");
      btnUpload.disabled = !hasFiles || isUploading || !hasPending;
      btnClear.disabled = isUploading;

      // Update global progress panel
      if (isUploading) {
        animateCounter(document.getElementById("gpComplete"), uploadStats.complete);
        animateCounter(document.getElementById("gpUploading"), uploadStats.uploading);
        animateCounter(document.getElementById("gpTotal"), uploadStats.total);
        
        // Calculate overall progress
        const totalProgress = fileQueue.reduce((sum, f) => sum + f.progress, 0);
        const avgProgress = uploadStats.total > 0 ? totalProgress / uploadStats.total : 0;
        document.getElementById("gpFill").style.width = `${avgProgress}%`;
        
        // Update phase text
        const currentFile = fileQueue.find(
          (f) =>
            f.status === "uploading" || f.status === "processing" || f.status === "queued",
        );
        if (currentFile) {
          document.getElementById("gpPhase").textContent = 
            currentFile.status === "processing"
              ? "Processing files..."
              : currentFile.status === "queued"
                ? "Queued for processing..."
                : "Uploading files...";
          
          // Show current file info
          const gpCurrentFile = document.getElementById("gpCurrentFile");
          gpCurrentFile.style.display = "flex";
          document.getElementById("gpFileName").textContent = currentFile.name;
          document.getElementById("gpFileProgress").textContent = `${currentFile.progress}%`;
          document.getElementById("gpFileSpeed").textContent = currentFile.speed || '--';
          document.getElementById("gpFileIcon").className = `fas ${getFileIcon(currentFile.type)}`;
        }

        // Calculate speed and ETA
        if (uploadStartTime && totalBytesUploaded > 0) {
          const elapsed = (Date.now() - uploadStartTime) / 1000;
          const speed = totalBytesUploaded / elapsed;
          document.getElementById("gpSpeed").textContent = `${formatSize(speed)}/s`;
          
          // Estimate remaining time
          const remainingBytes = fileQueue
            .filter(f => f.status === "pending" || f.status === "uploading")
            .reduce((sum, f) => sum + f.size * (1 - f.progress / 100), 0);
          
          if (speed > 0 && remainingBytes > 0) {
            const etaSeconds = remainingBytes / speed;
            document.getElementById("gpEta").textContent = formatEta(etaSeconds);
          }
        }
        
        // Highlight active stat
        document.getElementById("gpUploadingStat").classList.toggle('active', uploadStats.uploading > 0);
      }
    }

    function formatEta(seconds) {
      if (seconds < 60) return `~${Math.round(seconds)}s remaining`;
      if (seconds < 3600) return `~${Math.round(seconds / 60)}m remaining`;
      return `~${Math.round(seconds / 3600)}h remaining`;
    }

    function renderQueue() {
      if (fileQueue.length === 0) {
        queueList.innerHTML = `
          <div class="queue-empty">
            <i class="fas fa-inbox"></i>
            <p>No files in queue</p>
            <p style="font-size: 12px; margin-top: 8px;">Drop files or click above to add</p>
          </div>
        `;
        return;
      }

      queueList.innerHTML = fileQueue.map((item) => {
        const isLargeFile = item.size > 50 * 1024 * 1024; // >50MB shows chunk progress
        const totalChunks = isLargeFile ? Math.ceil(item.size / CHUNK_SIZE) : 0;
        const completedChunks = Math.floor((item.progress / 100) * totalChunks);
        
        const statusIcon = {
          pending: 'fa-clock',
          uploading: 'fa-arrow-up',
          queued: 'fa-hourglass-half',
          processing: 'fa-cog',
          complete: 'fa-check',
          error: 'fa-exclamation'
        }[item.status] || 'fa-clock';

        return `
          <div class="file-item ${item.status}" id="${item.id}">
            <div class="file-item-row">
              <div class="file-icon ${getFileIconClass(item.type)}">
                <i class="fas ${getFileIcon(item.type)}"></i>
              </div>
              <div class="file-details">
                <h4 title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</h4>
                <div class="file-meta">
                  <span><i class="fas fa-hdd"></i> ${formatSize(item.size)}</span>
                  <span><i class="fas fa-file"></i> ${item.type.toUpperCase()}</span>
                  ${isWhatsAppCandidate(item)
                    ? `<span class="whatsapp-badge"><i class="fab fa-whatsapp"></i> WhatsApp</span>`
                    : ""}
                  ${item.type === "pst"
                    ? `<span class="email-extracted"><i class="fas fa-envelope-open"></i> ${escapeHtml(formatExtractedEmailCount(item.processed_emails || 0, item.total_emails || 0))}</span>`
                    : ""}
                  ${item.error ? `<span style="color: #ef4444;"><i class="fas fa-exclamation-circle"></i> ${escapeHtml(item.error)}</span>` : ""}
                  ${item.note ? `<span style="color: var(--vericase-teal);"><i class="fas fa-info-circle"></i> ${escapeHtml(item.note)}</span>` : ""}
                </div>
              </div>
              <div class="file-progress-section">
                <div class="file-progress">
                  <div class="progress-bar">
                    <div class="progress-fill ${item.status === "complete" ? "complete" : ""} ${item.status === "error" ? "error" : ""}"
                         style="width: ${item.progress}%"></div>
                  </div>
                  <div class="progress-info">
                    <span class="progress-percent">${item.progress}%</span>
                    <span class="progress-speed">${item.speed || '--'}</span>
                  </div>
                </div>
              </div>
              <span class="file-status-badge ${item.status}">
                <i class="fas ${statusIcon}"></i>
                ${getStatusText(item.status)}
              </span>
              ${item.status === "pending" ? `
                <button class="file-remove" onclick="removeFile('${item.id}')" title="Remove">
                  <i class="fas fa-times"></i>
                </button>
              ` : ""}
            </div>
            ${isLargeFile && (item.status === "uploading" || item.status === "processing") ? `
              <div class="chunk-progress">
                <div class="chunk-header">
                  <span><i class="fas fa-puzzle-piece"></i> Chunk Progress</span>
                  <span>${completedChunks} / ${totalChunks} chunks</span>
                </div>
                <div class="chunk-grid">
                  ${Array.from({length: Math.min(totalChunks, 50)}, (_, i) => {
                    let chunkStatus = 'pending';
                    if (i < completedChunks) chunkStatus = 'complete';
                    else if (i === completedChunks) chunkStatus = 'uploading';
                    return `<div class="chunk-block ${chunkStatus}"></div>`;
                  }).join('')}
                  ${totalChunks > 50 ? `<span style="font-size: 10px; color: var(--text-muted);">+${totalChunks - 50} more</span>` : ''}
                </div>
              </div>
            ` : ''}
          </div>
        `;
      }).join("");
    }

    function getStatusText(status) {
      const texts = {
        pending: "Pending",
        uploading: "Uploading",
        queued: "Queued",
        processing: "Processing",
        complete: "Complete",
        error: "Failed",
      };
      return texts[status] || status;
    }

    function removeFile(id) {
      fileQueue = fileQueue.filter((f) => f.id !== id);
      updateStats();
      renderQueue();
    }

    function clearQueue() {
      if (isUploading) return;
      fileQueue = [];
      updateStats();
      renderQueue();
    }

    function updateFileItem(id, updates) {
      const item = fileQueue.find((f) => f.id === id);
      if (item) {
        const prevStatus = item.status;
        const prevProgress = item.progress;
        
        // Track upload speed
        if (updates.progress !== undefined && item.uploadStartTime) {
          const elapsed = (Date.now() - item.uploadStartTime) / 1000;
          if (elapsed > 0) {
            const bytesUploaded = (updates.progress / 100) * item.size;
            const speed = bytesUploaded / elapsed;
            updates.speed = `${formatSize(speed)}/s`;
          }
        }
        
        // Set upload start time when status changes to uploading
        if (updates.status === "uploading" && prevStatus !== "uploading") {
          item.uploadStartTime = Date.now();
        }
        
        Object.assign(item, updates);
        updateStats();

        if (updates.error !== undefined || updates.note !== undefined) {
          renderQueue();
          return;
        }

        // Update DOM directly for performance
        const el = document.getElementById(id);
        if (el) {
          el.className = `file-item ${item.status}`;
          
          const progressFill = el.querySelector(".progress-fill");
          const progressPercent = el.querySelector(".progress-percent");
          const progressSpeed = el.querySelector(".progress-speed");
          const statusBadge = el.querySelector(".file-status-badge");
          const emailExtracted = el.querySelector(".email-extracted");

          if (progressFill) {
            progressFill.style.width = `${item.progress}%`;
            progressFill.className = `progress-fill ${item.status === "complete" ? "complete" : ""} ${item.status === "error" ? "error" : ""}`;
          }
          if (progressPercent) progressPercent.textContent = `${item.progress}%`;
          if (progressSpeed) progressSpeed.textContent = item.speed || '--';
          if (emailExtracted && item.type === "pst") {
            emailExtracted.innerHTML =
              `<i class="fas fa-envelope-open"></i> ` +
              escapeHtml(formatExtractedEmailCount(item.processed_emails || 0, item.total_emails || 0));
          }
          
          if (statusBadge) {
            const statusIcon = {
              pending: 'fa-clock',
              uploading: 'fa-arrow-up',
              queued: 'fa-hourglass-half',
              processing: 'fa-cog',
              complete: 'fa-check',
              error: 'fa-exclamation'
            }[item.status] || 'fa-clock';
            
            statusBadge.className = `file-status-badge ${item.status}`;
            statusBadge.innerHTML = `<i class="fas ${statusIcon}"></i> ${getStatusText(item.status)}`;
          }
          
          // Update chunk progress for large files
          const chunkGrid = el.querySelector('.chunk-grid');
          if (chunkGrid && item.size > 50 * 1024 * 1024) {
            const totalChunks = Math.ceil(item.size / CHUNK_SIZE);
            const completedChunks = Math.floor((item.progress / 100) * totalChunks);
            const chunkBlocks = chunkGrid.querySelectorAll('.chunk-block');
            
            chunkBlocks.forEach((block, i) => {
              block.className = 'chunk-block';
              if (i < completedChunks) block.classList.add('complete');
              else if (i === completedChunks) block.classList.add('uploading');
            });
            
            const chunkHeader = el.querySelector('.chunk-header span:last-child');
            if (chunkHeader) {
              chunkHeader.textContent = `${completedChunks} / ${totalChunks} chunks`;
            }
          }
        }
        
        // Show toast notifications for status changes
        if (updates.status && updates.status !== prevStatus) {
          if (updates.status === "complete") {
            if (item.type === "pst") {
              ToastManager.success(
                "PST Processing Complete",
                `${item.name}  ${(item.processed_emails || 0).toLocaleString()} email${(item.processed_emails || 0) === 1 ? "" : "s"} extracted`
              );
            } else {
              ToastManager.success("Upload Complete", `${item.name} has been uploaded successfully`);
            }
          } else if (updates.status === "error") {
            ToastManager.error("Upload Failed", `${item.name}: ${item.error || 'Unknown error'}`);
          } else if (updates.status === "queued") {
            ToastManager.info("Queued for Processing", `${item.name} is waiting for a processor`);
          } else if (updates.status === "processing") {
            ToastManager.info("Processing Started", `${item.name} is now being processed`);
          }
        }
      }
    }

    // Main upload orchestrator
    async function startUpload() {
      if (isUploading) return;

      isUploading = true;
      uploadStartTime = Date.now();
      totalBytesUploaded = 0;

      uploadZone.classList.add("uploading");
      globalProgress.classList.add("active");
      updateStats();

      const pendingFiles = fileQueue.filter((f) => f.status === "pending");

      // Group files by type for optimal upload strategy
      const pstFiles = pendingFiles.filter((f) => f.type === "pst");
      const emailTypes = ["eml", "msg", "txt", "zip", "pdf"];
      const emailFiles = pendingFiles.filter((f) => emailTypes.includes(f.type));
      const otherFiles = pendingFiles.filter(
        (f) => !["pst", ...emailTypes].includes(f.type),
      );

      try {
        // Upload PST files with controlled concurrency (1 at a time due to size)
        for (const item of pstFiles) {
          await uploadPSTFile(item);
        }

        // Upload standalone email files (EML/MSG) into Correspondence.
        // These are treated as if they were ingested from a PST (synthetic PSTFile container).
        if (emailFiles.length > 0) {
          await uploadEmailFilesAsCorrespondence(emailFiles);
        }

        // Upload other files with concurrency
        await uploadWithConcurrency(otherFiles, MAX_CONCURRENT);
      } catch (error) {
        console.error("Upload error:", error);
      }

      isUploading = false;
      uploadZone.classList.remove("uploading");

      // Show completion
      setTimeout(() => {
        globalProgress.classList.remove("active");
        document.getElementById("gpCurrentFile").style.display = "none";
        loadPSTHistory();

        if (uploadStats.complete > 0) {
          if (uploadStats.errors > 0) {
            ToastManager.warning(
              "Upload Complete",
              `${uploadStats.complete} succeeded, ${uploadStats.errors} failed`
            );
          } else {
            ToastManager.success(
              "All Uploads Complete!",
              `${uploadStats.complete} file${uploadStats.complete > 1 ? 's' : ''} uploaded successfully`
            );
          }
        }
      }, 1500);
    }

    // Concurrent upload helper
    async function uploadWithConcurrency(items, maxConcurrent) {
      const executing = new Set();

      for (const item of items) {
        const promise = uploadRegularFile(item).finally(() =>
          executing.delete(promise),
        );
        executing.add(promise);

        if (executing.size >= maxConcurrent) {
          await Promise.race(executing);
        }
      }

      await Promise.all(executing);
    }

    // Upload PST file with progress
    async function uploadPSTFile(item) {
      updateFileItem(item.id, { status: "uploading", progress: 0 });

      // Pick the safest path per size: multipart for large, presigned PUT for medium, server for tiny
      const BYTES_MB = 1024 * 1024;
      const isHuge = item.size > 500 * BYTES_MB; // >500MB
      const isLarge = item.size > 100 * BYTES_MB; // >100MB
      const isSmall = item.size <= 20 * BYTES_MB; // <=20MB

      try {
        if (isHuge || isLarge) {
          await uploadPSTMultipart(item);
        } else if (isSmall) {
          // small files keep server-side for simplicity
          await uploadPSTViaServer(item);
        } else {
          // medium files: direct presigned PUT
          await uploadPSTDirect(item);
        }

        updateFileItem(item.id, { status: "processing", progress: 100 });
        totalBytesUploaded += item.size;

        if (item.pst_file_id) {
          startPstProcessingMonitor(item.id, item.pst_file_id);
        }
      } catch (error) {
        console.error(`PST upload error for ${item.name}:`, error);
        updateFileItem(item.id, { status: "error", error: error.message });
        return;
      }
    }

    async function uploadPSTViaServer(item) {
      const BYTES_MB = 1024 * 1024;

      // Safety net: if an older cached build routes large PSTs here, bounce to the right flow
      if (item.size > 20 * BYTES_MB) {
        console.warn(
          "Large PST routed to legacy /pst/upload endpoint; switching to presigned flow.",
        );
        if (item.size > 100 * BYTES_MB) {
          return uploadPSTMultipart(item);
        }
        return uploadPSTDirect(item);
      }

      const formData = new FormData();
      formData.append("file", item.file);

      if (VeriCaseApp.projectId) {
        formData.append("project_id", VeriCaseApp.projectId);
      } else if (VeriCaseApp.caseId) {
        formData.append("case_id", VeriCaseApp.caseId);
      } else {
        // Fallback or error handling
        console.warn("No project or case ID found for upload");
      }

      // Use XMLHttpRequest for progress tracking
      await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const uploadUrl = `${apiUrl}/api/correspondence/pst/upload`;
        console.log("Uploading PST to:", uploadUrl);
        xhr.open("POST", uploadUrl, true);

        // Add Authorization header for authenticated upload
        const token =
          localStorage.getItem("vericase_token") ||
          localStorage.getItem("token") ||
          localStorage.getItem("jwt") ||
          localStorage.getItem("access_token");
        if (token) {
          xhr.setRequestHeader("Authorization", `Bearer ${token}`);
        }

        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 95);
            updateFileItem(item.id, { progress: pct });
          }
        };

        xhr.onload = () => {
          if (xhr.status < 400) {
            let pstFileId = null;
            try {
              const payload = JSON.parse(xhr.responseText || "{}");
              pstFileId = payload.pst_file_id || payload.pstFileId || null;
            } catch (e) {
              pstFileId = null;
            }
            if (pstFileId) {
              updateFileItem(item.id, { pst_file_id: pstFileId });
            }
            updateFileItem(item.id, { status: "processing", progress: 100 });
            resolve();
          } else if ([413, 502, 504].includes(xhr.status)) {
            // Fall back to presigned/multipart when API rejects large uploads
            const fallback =
              item.size > 100 * BYTES_MB
                ? uploadPSTMultipart(item)
                : uploadPSTDirect(item);
            fallback.then(resolve).catch(reject);
          } else {
            reject(new Error(`Upload failed: ${xhr.status}`));
          }
        };

        xhr.onerror = () => {
          const fallback =
            item.size > 100 * BYTES_MB
              ? uploadPSTMultipart(item)
              : uploadPSTDirect(item);
          fallback.then(resolve).catch((err) => {
            console.error("Fallback upload also failed", err);
            reject(new Error("Network error"));
          });
        };
        xhr.send(formData);
      });
    }

    async function uploadPSTDirect(item) {
      // Initialize upload
      const initBody = {
        filename: item.name,
        file_size: item.size,
      };

      if (VeriCaseApp.projectId) {
        initBody.project_id = VeriCaseApp.projectId;
      } else if (VeriCaseApp.caseId) {
        initBody.case_id = VeriCaseApp.caseId;
      }

      const initResp = await fetch(
        `${apiUrl}/api/correspondence/pst/upload/init`,
        withAuth({
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(initBody),
        }),
      );

      if (!initResp.ok) throw new Error("Failed to initialize upload");

      const { pst_file_id, upload_url } = await initResp.json();
      if (pst_file_id) {
        updateFileItem(item.id, { pst_file_id });
      }

      // Upload with progress
      await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("PUT", upload_url, true);
        xhr.setRequestHeader("Content-Type", "application/vnd.ms-outlook");

        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.round((e.loaded / e.total) * 90); // 90% for upload
            updateFileItem(item.id, { progress: pct });
          }
        };

        xhr.onload = () =>
          xhr.status < 400
            ? resolve()
            : reject(new Error(`Upload failed: ${xhr.status}`));
        xhr.onerror = () => reject(new Error("Network error"));
        xhr.send(item.file);
      });

      updateFileItem(item.id, { status: "processing", progress: 95 });

      // Start processing
      const processResp = await fetch(
        `${apiUrl}/api/correspondence/pst/${pst_file_id}/process`,
        withAuth({ method: "POST" }),
      );
      if (!processResp.ok) {
        let detail = "";
        try {
          detail = await processResp.text();
        } catch (e) {
          detail = "";
        }
        throw new Error(
          `Failed to start PST processing (HTTP ${processResp.status})${
            detail ? `: ${detail}` : ""
          }`,
        );
      }
    }

    async function uploadPSTMultipart(item) {
      // Persist multipart session state so we can resume after browser refresh/crash.
      // Keyed by (scope + filename + size + lastModified) to avoid collisions.
      const resumeScope = VeriCaseApp.projectId
        ? `project:${VeriCaseApp.projectId}`
        : VeriCaseApp.caseId
          ? `case:${VeriCaseApp.caseId}`
          : "unknown";
      const lastModified =
        item.file && typeof item.file.lastModified === "number"
          ? item.file.lastModified
          : 0;
      const resumeKey = `vericase_pst_mpu:${resumeScope}:${item.name}:${item.size}:${lastModified}`;

      const loadResume = () => {
        try {
          const raw = localStorage.getItem(resumeKey);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (!parsed || parsed.version !== 1) return null;
          if (parsed.file_size !== item.size) return null;
          return parsed;
        } catch (e) {
          return null;
        }
      };
      const saveResume = (state) => {
        try {
          localStorage.setItem(resumeKey, JSON.stringify(state));
        } catch (e) {
          // Ignore storage quota issues; upload can still proceed.
        }
      };
      const clearResume = () => {
        try {
          localStorage.removeItem(resumeKey);
        } catch (e) {}
      };

      let resumeState = loadResume();
      let pst_file_id = resumeState?.pst_file_id || null;
      let upload_id = resumeState?.upload_id || null;
      let actualChunkSize = resumeState?.chunk_size || CHUNK_SIZE;

      // If we have a prior session, refresh parts from the server (authoritative) to resume safely.
      if (pst_file_id && upload_id) {
        try {
          const partsResp = await fetch(
            `${apiUrl}/api/correspondence/pst/upload/multipart/parts?pst_file_id=${encodeURIComponent(pst_file_id)}&upload_id=${encodeURIComponent(upload_id)}`,
            withAuth({}),
          );
          if (partsResp.ok) {
            const partsData = await partsResp.json();
            const serverParts = Array.isArray(partsData?.parts) ? partsData.parts : [];
            resumeState = {
              version: 1,
              pst_file_id,
              upload_id,
              filename: item.name,
              file_size: item.size,
              chunk_size: actualChunkSize,
              parts: serverParts.map((p) => ({
                ETag: String(p?.ETag || "").replace(/"/g, ""),
                PartNumber: Number(p?.PartNumber || 0),
              })),
              created_at: resumeState?.created_at || Date.now(),
              updated_at: Date.now(),
            };
            saveResume(resumeState);
          } else {
            // Upload no longer exists server-side (e.g., aborted/expired)  start fresh.
            clearResume();
            resumeState = null;
            pst_file_id = null;
            upload_id = null;
          }
        } catch (e) {
          // Network/auth hiccup: keep local state and try continuing (best-effort).
        }
      }

      // Start a fresh multipart upload if we can't resume.
      if (!pst_file_id || !upload_id) {
        const initBody = {
          filename: item.name,
          file_size: item.size,
          content_type: "application/vnd.ms-outlook",
        };

        if (VeriCaseApp.projectId) initBody.project_id = VeriCaseApp.projectId;
        else if (VeriCaseApp.caseId) initBody.case_id = VeriCaseApp.caseId;

        const initResp = await fetch(
          `${apiUrl}/api/correspondence/pst/upload/multipart/init`,
          withAuth({
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(initBody),
          }),
        );

        if (!initResp.ok) throw new Error("Failed to initialize multipart upload");

        const initData = await initResp.json();
        pst_file_id = initData?.pst_file_id;
        upload_id = initData?.upload_id;
        actualChunkSize = initData?.chunk_size || CHUNK_SIZE;

        resumeState = {
          version: 1,
          pst_file_id,
          upload_id,
          filename: item.name,
          file_size: item.size,
          chunk_size: actualChunkSize,
          parts: [],
          created_at: Date.now(),
          updated_at: Date.now(),
        };
        saveResume(resumeState);
      }

      if (pst_file_id) {
        updateFileItem(item.id, { pst_file_id });
      }

      const totalChunks = Math.ceil(item.size / actualChunkSize);

      // Build a canonical parts map (PartNumber -> {ETag, PartNumber}) for resume/complete.
      const partsMap = new Map();
      const normalizePart = (p) => {
        if (!p) return null;
        const pn = Number(p.PartNumber || p.partNumber || p.part_number || 0);
        const et = String(p.ETag || p.etag || "").replace(/"/g, "");
        if (!pn || !et) return null;
        return { ETag: et, PartNumber: pn };
      };
      (resumeState?.parts || []).forEach((p) => {
        const np = normalizePart(p);
        if (np) partsMap.set(np.PartNumber, np);
      });

      // URL cache for batch-prefetched presigned URLs
      const urlCache = new Map();
      const URL_BATCH_SIZE = 16; // Fetch 16 URLs at a time

      // Prefetch URLs for upcoming parts to reduce round-trips
      const prefetchUrls = async (startPart) => {
        // Don't prefetch if we already have enough cached URLs
        const uncachedCount = Array.from({ length: URL_BATCH_SIZE }, (_, i) => startPart + i)
          .filter(pn => pn <= totalChunks && !urlCache.has(pn) && !partsMap.has(pn)).length;
        if (uncachedCount < URL_BATCH_SIZE / 2) return;

        try {
          const resp = await fetch(
            `${apiUrl}/api/correspondence/pst/upload/multipart/batch-urls`,
            withAuth({
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                pst_file_id,
                upload_id,
                start_part: startPart,
                count: URL_BATCH_SIZE,
              }),
            }),
          );
          if (resp.ok) {
            const data = await resp.json();
            (data.urls || []).forEach(({ part_number, url }) => {
              if (!urlCache.has(part_number)) {
                urlCache.set(part_number, url);
              }
            });
          }
        } catch (e) {
          // Silent fail - will fall back to single URL fetch
          console.debug("Batch URL prefetch failed, will use single fetch", e);
        }
      };

      // Upload parts in parallel (up to 8 concurrent for optimal throughput on fast connections)
      const MAX_PART_CONCURRENCY = 8;
      const uploadPart = async (partNumber) => {
        // Skip already-uploaded parts when resuming.
        if (partsMap.has(partNumber)) {
          return partsMap.get(partNumber);
        }

        const start = (partNumber - 1) * actualChunkSize;
        const end = Math.min(start + actualChunkSize, item.size);
        const chunk = item.file.slice(start, end);

        // Check URL cache first, then fall back to single URL fetch
        let url = urlCache.get(partNumber);
        if (!url) {
          const partUrlResp = await fetch(
            `${apiUrl}/api/correspondence/pst/upload/multipart/part?pst_file_id=${pst_file_id}&upload_id=${encodeURIComponent(upload_id)}&part_number=${partNumber}`,
          );
          if (!partUrlResp.ok)
            throw new Error(`Failed to get URL for part ${partNumber}`);
          const data = await partUrlResp.json();
          url = data.url;
        }

        const uploadResp = await fetchWithRetry(
          url,
          {
            method: "PUT",
            body: chunk,
            headers: { "Content-Type": "application/octet-stream" },
          },
          3,
        );

        if (!uploadResp.ok)
          throw new Error(`Failed to upload part ${partNumber}`);

        const rawEtag = uploadResp.headers.get("ETag");
        if (!rawEtag) {
          throw new Error(
            "Missing ETag header from S3. Bucket CORS must ExposeHeaders: ETag.",
          );
        }

        const part = { ETag: rawEtag.replace(/"/g, ""), PartNumber: partNumber };
        partsMap.set(partNumber, part);

        // Persist progress so we can resume later.
        if (resumeState) {
          resumeState.parts = Array.from(partsMap.values()).map((p) => ({
            ETag: p.ETag,
            PartNumber: p.PartNumber,
          }));
          resumeState.updated_at = Date.now();
          saveResume(resumeState);
        }

        return part;
      };

      // Upload all parts with controlled concurrency and URL prefetching
      updateFileItem(item.id, {
        progress: Math.round((partsMap.size / totalChunks) * 85),
      });

      // Prefetch URLs for first batch before starting
      await prefetchUrls(1);

      for (let i = 0; i < totalChunks; i += MAX_PART_CONCURRENCY) {
        // Prefetch URLs for next batch while uploading current batch
        const nextBatchStart = i + MAX_PART_CONCURRENCY + 1;
        if (nextBatchStart <= totalChunks) {
          prefetchUrls(nextBatchStart); // Fire and forget, don't await
        }

        const batch = [];
        for (let j = 0; j < MAX_PART_CONCURRENCY && i + j < totalChunks; j++) {
          batch.push(uploadPart(i + j + 1));
        }
        await Promise.all(batch);

        const pct = Math.round((partsMap.size / totalChunks) * 85);
        updateFileItem(item.id, { progress: pct });
      }

      // Build completion parts (only the fields the backend/boto3 accepts).
      const parts = Array.from(partsMap.values())
        .sort((a, b) => a.PartNumber - b.PartNumber)
        .map((p) => ({ ETag: p.ETag, PartNumber: p.PartNumber }));

      // Complete multipart
      const completeResp = await fetch(
        `${apiUrl}/api/correspondence/pst/upload/multipart/complete`,
        withAuth({
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ pst_file_id, upload_id, parts }),
        }),
      );

      if (!completeResp.ok)
        throw new Error("Failed to complete multipart upload");

      let completionData = null;
      try {
        completionData = await completeResp.json();
      } catch (e) {
        completionData = null;
      }

      updateFileItem(item.id, { status: "processing", progress: 95 });

      // Completion succeeded, clear resume state (prevents dangling resumes).
      clearResume();

      if (!completionData?.processing_started) {
        const processResp = await fetch(
          `${apiUrl}/api/correspondence/pst/${pst_file_id}/process`,
          withAuth({ method: "POST" }),
        );
        if (!processResp.ok) {
          let detail = "";
          try {
            detail = await processResp.text();
          } catch (e) {
            detail = "";
          }
          throw new Error(
            `Failed to start PST processing (HTTP ${processResp.status})${
              detail ? `: ${detail}` : ""
            }`,
          );
        }
      }
    }

    // Bulk email upload
    // NOTE: Deprecated. The API does not implement /api/evidence/upload-bulk.
    // Keep this wrapper for backward-compatibility; it now uploads files individually.
    async function uploadEmailsBulk(items) {
      // Backward-compat wrapper: these are now imported into Correspondence.
      await uploadEmailFilesAsCorrespondence(items);
    }

    async function uploadEmailFilesAsCorrespondence(items) {
      if (!items || items.length === 0) return;

      // Create a synthetic PSTFile container for this batch.
      let pstFileId = null;
      try {
        const body = {
          case_id: VeriCaseApp.caseId || null,
          project_id: VeriCaseApp.projectId || null,
          batch_name: `Email import (${items.length} file${items.length === 1 ? "" : "s"})`,
        };

        const initResp = await fetch(
          `${apiUrl}/api/correspondence/email-import/init`,
          withAuth({
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          }),
        );

        if (!initResp.ok) {
          const detail = (await initResp.text()).trim();
          throw new Error(
            `Failed to init email import (HTTP ${initResp.status})${detail ? `: ${detail}` : ""}`,
          );
        }

        const initData = await initResp.json();
        pstFileId = initData?.pst_file_id || initData?.pstFileId || null;
        if (!pstFileId) throw new Error("Email import init did not return pst_file_id");
      } catch (e) {
        const msg = e?.message || String(e);
        items.forEach((it) => updateFileItem(it.id, { status: "error", error: msg }));
        return;
      }

      // Upload each email file into the batch.
      const maxConcurrent = Math.min(MAX_CONCURRENT, 2);
      const executing = new Set();
      let duplicateCount = 0;
      let mergedCount = 0;
      let mergedAttachments = 0;

      for (const item of items) {
        const promise = uploadEmailImportFile(item, pstFileId)
          .then((payload) => {
            if (payload?.duplicate) {
              duplicateCount += 1;
              if (payload?.attachments_merged) {
                mergedCount += 1;
                mergedAttachments += Number(payload.attachments_added || 0);
              }
            }
            return payload;
          })
          .finally(() => executing.delete(promise));
        executing.add(promise);
        if (executing.size >= maxConcurrent) {
          await Promise.race(executing);
        }
      }
      await Promise.all(executing);

      // Finalize: run threading + dedupe and mark the synthetic PSTFile as completed.
      try {
        items.forEach((it) => {
          if (it.status !== "error") updateFileItem(it.id, { status: "processing", progress: 100 });
        });

        const finResp = await fetch(
          `${apiUrl}/api/correspondence/email-import/${encodeURIComponent(pstFileId)}/finalize`,
          withAuth({ method: "POST" }),
        );
        if (!finResp.ok) {
          const detail = (await finResp.text()).trim();
          throw new Error(
            `Failed to finalize email import (HTTP ${finResp.status})${detail ? `: ${detail}` : ""}`,
          );
        }

        items.forEach((it) => {
          if (it.status !== "error") updateFileItem(it.id, { status: "complete", progress: 100 });
        });

        if (duplicateCount > 0) {
          const mergedNote =
            mergedCount > 0
              ? ` (${mergedCount} merged, ${mergedAttachments} attachment${mergedAttachments === 1 ? "" : "s"} added)`
              : "";
          ToastManager.info(
            "Duplicates Skipped",
            `${duplicateCount} duplicate email${duplicateCount === 1 ? "" : "s"} skipped${mergedNote}`
          );
        }
      } catch (e) {
        const msg = e?.message || String(e);
        items.forEach((it) => {
          if (it.status !== "error") updateFileItem(it.id, { status: "error", error: msg });
        });
      }
    }

    async function uploadEmailImportFile(item, pstFileId) {
      updateFileItem(item.id, { status: "uploading", progress: 0 });

      try {
        const formData = new FormData();
        formData.append("file", item.file);

        const maxAttempts = 3;
        const retryableStatuses = new Set([0, 429, 502, 503, 504]);

        const attemptUpload = () =>
          new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open(
              "POST",
              `${apiUrl}/api/correspondence/email-import/${encodeURIComponent(pstFileId)}/upload`,
              true,
            );
            // Prevent the UI getting stuck forever on a hung request.
            xhr.timeout = 600000; // 10 minutes

            const token =
              localStorage.getItem("vericase_token") ||
              localStorage.getItem("token") ||
              localStorage.getItem("jwt") ||
              localStorage.getItem("access_token");
            if (token) {
              xhr.setRequestHeader("Authorization", `Bearer ${token}`);
            }

            xhr.upload.onprogress = (e) => {
              if (e.lengthComputable) {
                const pct = Math.round((e.loaded / e.total) * 100);
                updateFileItem(item.id, { progress: pct });
              }
            };

            xhr.onload = () => {
              if (xhr.status < 400) {
                let payload = {};
                try {
                  payload = JSON.parse(xhr.responseText || "{}");
                } catch (e) {
                  payload = {};
                }
                resolve({ status: xhr.status, payload });
                return;
              }
              const detail = (xhr.responseText || "").trim();
              const err = new Error(
                `Email import upload failed: ${xhr.status}${detail ? `: ${detail}` : ""}`,
              );
              err.status = xhr.status;
              reject(err);
            };

            xhr.onerror = () => {
              const err = new Error("Network error");
              err.status = 0;
              reject(err);
            };
            xhr.ontimeout = () => {
              const err = new Error("Upload timed out");
              err.status = 0;
              reject(err);
            };
            xhr.send(formData);
          });

        let responsePayload = null;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          try {
            const result = await attemptUpload();
            responsePayload = result?.payload || {};
            break;
          } catch (error) {
            const status = error?.status ?? 0;
            if (attempt < maxAttempts && retryableStatuses.has(status)) {
              await new Promise((r) => setTimeout(r, 1500 * attempt));
              continue;
            }
            throw error;
          }
        }

        let note = null;
        if (responsePayload?.duplicate) {
          const added = Number(responsePayload.attachments_added || 0);
          note = responsePayload.attachments_merged
            ? `Duplicate merged (${added} attachment${added === 1 ? "" : "s"})`
            : "Duplicate skipped";
        }

        // Hold in processing state until batch finalize completes.
        updateFileItem(item.id, { status: "processing", progress: 100, note });
        totalBytesUploaded += item.size;
        return responsePayload;
      } catch (error) {
        console.error(`Email import upload error for ${item.name}:`, error);
        updateFileItem(item.id, { status: "error", error: error.message });
        return null;
      }
    }

    // Regular file upload (Evidence Repository direct upload)
    async function uploadRegularFile(item) {
      updateFileItem(item.id, { status: "uploading", progress: 0 });

      try {
        const formData = new FormData();
        formData.append("file", item.file);
        if (VeriCaseApp.projectId) formData.append("project_id", VeriCaseApp.projectId);
        if (VeriCaseApp.caseId) formData.append("case_id", VeriCaseApp.caseId);

        // Use XMLHttpRequest for progress
        await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("POST", `${apiUrl}/api/evidence/upload/direct`, true);

          // Add Authorization header for authenticated upload
          const token =
            localStorage.getItem("vericase_token") ||
            localStorage.getItem("token") ||
            localStorage.getItem("jwt") ||
            localStorage.getItem("access_token");
          if (token) {
            xhr.setRequestHeader("Authorization", `Bearer ${token}`);
          }

          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const pct = Math.round((e.loaded / e.total) * 100);
              updateFileItem(item.id, { progress: pct });
            }
          };

          xhr.onload = () => {
            if (xhr.status < 400) {
              resolve();
              return;
            }
            // Include server detail when available; helps debug 4xx like 404/413.
            const detail = (xhr.responseText || "").trim();
            reject(
              new Error(
                `Upload failed: ${xhr.status}${detail ? `: ${detail}` : ""}`,
              ),
            );
          };

          xhr.onerror = () => reject(new Error("Network error"));
          xhr.send(formData);
        });

        updateFileItem(item.id, { status: "complete", progress: 100 });
        totalBytesUploaded += item.size;
      } catch (error) {
        console.error(`Upload error for ${item.name}:`, error);
        updateFileItem(item.id, { status: "error", error: error.message });
      }
    }

    // History
    async function loadPSTHistory() {
      const historyContent = document.getElementById("historyContent");
      historyContent.innerHTML = `
                <div class="no-history">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading history...</p>
                </div>
            `;

      try {
        const params = new URLSearchParams();
        if (VeriCaseApp.projectId) {
          params.append("project_id", VeriCaseApp.projectId);
        } else if (VeriCaseApp.caseId) {
          params.append("case_id", VeriCaseApp.caseId);
        } else {
          throw new Error("No active project/case selected");
        }
        params.append("page_size", "20");

        const response = await fetch(
          `${apiUrl}/api/correspondence/pst/files?${params}`,
          withAuth({}),
        );
        if (!response.ok) throw new Error("Failed to load history");

        const data = await response.json();
        displayHistory(data);
      } catch (error) {
        console.error("Error loading history:", error);
        historyContent.innerHTML = `
                    <div class="no-history">
                        <i class="fas fa-exclamation-triangle" style="color: #ef4444;"></i>
                        <p>Failed to load upload history</p>
                    </div>
                `;
      }
    }

    function displayHistory(data) {
      const historyContent = document.getElementById("historyContent");

      if (!data.items || data.items.length === 0) {
        historyContent.innerHTML = `
                    <div class="no-history">
                        <i class="fas fa-inbox"></i>
                        <p>No uploads yet</p>
                    </div>
                `;
        return;
      }

      const formatTotalEmailsForDisplay = (pst) => {
        const total = Number(pst?.total_emails || 0);
        const status = String(pst?.processing_status || "").toLowerCase();
        // Many deployments disable PST pre-count; total_emails stays 0 until completion.
        // Showing "0 of 0" is misleading for pending/processing/failed, so show "?" instead.
        if (total > 0) return total.toLocaleString();
        if (
          status === "queued" ||
          status === "pending" ||
          status === "processing" ||
          status === "failed"
        )
          return "?";
        return "0";
      };

      historyContent.innerHTML = `
                <table class="history-table">
                    <thead>
                        <tr>
                            <th>Filename</th>
                            <th>Size</th>
                            <th>Emails</th>
                            <th>Status</th>
                            <th>Uploaded</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${data.items
          .map(
            (pst) => `
                            <tr>
                                <td>
                                    <span class="history-filename">
                                        <i class="fas fa-envelope"></i>
                                        ${escapeHtml(pst.filename)}
                                    </span>
                                </td>
                                <td>${formatSize(pst.file_size_bytes || 0)}</td>
                                <td>
                                    <div class="email-count">
                                        <span class="processed">${(pst.processed_emails || 0).toLocaleString()}</span>
                                        <span class="total">of ${formatTotalEmailsForDisplay(pst)}</span>
                                    </div>
                                </td>
                                <td>${getStatusBadge(pst.processing_status, pst.error_message)}</td>
                                <td>${formatDate(pst.uploaded_at)}</td>
                                <td class="history-actions">
                                    ${getActionButtons(pst)}
                                </td>
                            </tr>
                        `,
          )
          .join("")}
                    </tbody>
                </table>
            `;
    }

    function getStatusBadge(status, errorMessage) {
      const safeError = escapeHtml(errorMessage || "");
      const badges = {
        queued:
          '<span class="status-badge status-pending"><i class="fas fa-hourglass-half"></i> Queued</span>',
        pending:
          '<span class="status-badge status-pending"><i class="fas fa-clock"></i> Pending</span>',
        uploaded:
          '<span class="status-badge status-pending"><i class="fas fa-cloud"></i> Uploaded</span>',
        processing:
          '<span class="status-badge status-processing"><i class="fas fa-spinner fa-spin"></i> Processing</span>',
        completed:
          '<span class="status-badge status-completed"><i class="fas fa-check"></i> Complete</span>',
        failed:
          `<span class="status-badge status-failed" title="${safeError || "PST processing failed"}"><i class="fas fa-times"></i> Failed</span>`,
      };
      return badges[status] || `<span class="status-badge">${escapeHtml(status)}</span>`;
    }

    function getActionButtons(pst) {
      const buttons = [];
      const safeId = escapeHtml(String(pst.id || ""));
      const status = String(pst.processing_status || "").toLowerCase();
      const filename = String(pst.filename || "");
      const isEmailImport = filename.toLowerCase().endsWith(".email_import.json");
      const processed = Number(pst.processed_emails || 0);
      const total = Number(pst.total_emails || 0);
      const isEmpty = processed <= 0 && total <= 0;

      const deleteBtn = `<button class="btn-icon btn-danger" data-action="delete" data-id="${safeId}" title="Delete upload"><i class="fas fa-trash"></i></button>`;

      // Email imports are *not* processed by the PST worker. Keep actions scoped.
      if (isEmailImport) {
        if (status === "processing") {
          buttons.push(
            `<button class="btn-icon" data-action="status" data-id="${safeId}" title="Check Status"><i class="fas fa-sync-alt"></i></button>`,
          );
        }

        if (status === "failed") {
          buttons.push(
            `<button class="btn-icon" data-action="error" data-id="${safeId}" title="View Error"><i class="fas fa-exclamation-circle"></i></button>`,
          );
        }

        if (status === "completed" && processed > 0) {
          buttons.push(
            `<button class="btn-icon" data-action="view" data-id="${safeId}" title="View Emails"><i class="fas fa-envelope-open-text"></i></button>`,
          );
        }

        // Allow deleting failed imports (or empty "completed" imports, which are nearly always failed uploads).
        if (status === "failed" || (status === "completed" && isEmpty)) {
          buttons.push(deleteBtn);
        }

        return buttons.join("") || '<span style="color: #606080;"></span>';
      }

      if (
        pst.processing_status === "uploaded" ||
        pst.processing_status === "queued" ||
        pst.processing_status === "pending" ||
        pst.processing_status === "failed"
      ) {
        buttons.push(
          `<button class="btn-icon" data-action="process" data-id="${safeId}" title="${pst.processing_status === "failed" ? "Retry Processing" : "Start Processing"}"><i class="fas ${pst.processing_status === "failed" ? "fa-redo" : "fa-play"}"></i></button>`,
        );
      }

      if (pst.processing_status === "processing") {
        buttons.push(
          `<button class="btn-icon" data-action="status" data-id="${safeId}" title="Check Status"><i class="fas fa-sync-alt"></i></button>`,
        );
        buttons.push(
          `<button class="btn-icon" data-action="rescue" data-id="${safeId}" title="Admin Rescue (Finalize)"><i class="fas fa-life-ring"></i></button>`,
        );
      }

      if (pst.processing_status === "failed") {
        buttons.push(
          `<button class="btn-icon" data-action="error" data-id="${safeId}" title="View Error"><i class="fas fa-exclamation-circle"></i></button>`,
        );
        if ((pst.processed_emails || 0) > 0) {
          buttons.push(
            `<button class="btn-icon" data-action="rescue" data-id="${safeId}" title="Admin Rescue (Finalize)"><i class="fas fa-life-ring"></i></button>`,
          );
        }
        buttons.push(deleteBtn);
      }

      if (pst.processing_status === "completed" && pst.processed_emails > 0) {
        buttons.push(
          `<button class="btn-icon" data-action="view" data-id="${safeId}" title="View Emails"><i class="fas fa-envelope-open-text"></i></button>`,
        );
      }

      return buttons.join("") || '<span style="color: #606080;"></span>';
    }

    function formatDate(dateStr) {
      if (!dateStr) return "";
      const date = new Date(dateStr);
      return date.toLocaleDateString("en-GB", {
        day: "2-digit",
        month: "short",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit",
      });
    }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    async function processPST(pstFileId) {
      try {
        const response = await fetch(
          `${apiUrl}/api/correspondence/pst/${pstFileId}/process`,
          withAuth({ method: "POST" }),
        );
        if (!response.ok) {
          let detail = "";
          try {
            detail = await response.text();
          } catch (e) {
            detail = "";
          }
          throw new Error(
            `Failed to start processing (HTTP ${response.status})${
              detail ? `: ${detail}` : ""
            }`,
          );
        }
        let payload = null;
        try {
          payload = await response.json();
        } catch (e) {
          payload = null;
        }
        const msg =
          (payload && payload.message) ||
          "Processing request accepted. Check status for progress.";
        if (window.ToastManager && typeof window.ToastManager.info === "function") {
          window.ToastManager.info("PST Processing", msg);
        } else {
          alert(msg);
        }
        loadPSTHistory();
      } catch (error) {
        alert("Failed to start processing: " + error.message);
      }
    }

    async function checkStatus(pstFileId) {
      try {
        const response = await fetch(
          `${apiUrl}/api/correspondence/pst/${pstFileId}/status`,
          withAuth({}),
        );
        if (!response.ok) throw new Error("Failed to get status");
        const status = await response.json();
        const totalEmails = Number(status.total_emails || 0);
        const processedEmails = Number(status.processed_emails || 0);
        const totalDisplay = totalEmails > 0 ? totalEmails : "?";
        const progressDisplay =
          totalEmails > 0
            ? `${status.progress_percent}%`
            : processedEmails > 0
              ? "Calculating..."
              : "0%";
        const err = status.error_message ? `\nError: ${status.error_message}` : "";
        alert(
          `Status: ${status.status}\nProgress: ${progressDisplay}\nProcessed: ${processedEmails}/${totalDisplay} emails${err}`,
        );
        loadPSTHistory();
      } catch (error) {
        alert("Failed to get status: " + error.message);
      }
    }

    async function rescuePST(pstFileId) {
      const ok = confirm(
        "Admin rescue will finalize this PST based on emails already extracted into the database.\n\nContinue?",
      );
      if (!ok) return;

      try {
        const response = await fetch(
          `${apiUrl}/api/correspondence/pst/${pstFileId}/admin/rescue`,
          withAuth({
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ action: "finalize" }),
          }),
        );

        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || "Rescue failed");
        }

        const result = await response.json();
        const toStatus = result.to_status || result.status || "completed";
        ToastManager.success("PST rescued", `Status: ${toStatus}`);
        loadPSTHistory();
      } catch (error) {
        alert("Failed to rescue PST: " + error.message);
      }
    }

    async function showPSTError(pstFileId) {
      try {
        const response = await fetch(
          `${apiUrl}/api/correspondence/pst/${pstFileId}/status`,
          withAuth({}),
        );
        if (!response.ok) throw new Error("Failed to get status");
        const status = await response.json();
        const err = status.error_message || "No error message recorded for this PST.";
        alert(`PST Error:\n\n${err}`);
      } catch (error) {
        alert("Failed to load error details: " + error.message);
      }
    }

    async function deletePSTUpload(pstFileId) {
      const ok = confirm(
        "Delete this upload?\n\nThis will remove the upload record and any extracted emails/attachments created by it.\n\nThis cannot be undone.",
      );
      if (!ok) return;

      try {
        const resp = await fetch(
          `${apiUrl}/api/correspondence/pst/${encodeURIComponent(pstFileId)}/delete`,
          withAuth({
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ delete_s3: true }),
          }),
        );

        if (!resp.ok) {
          const detail = (await resp.text()).trim();
          throw new Error(detail || `Delete failed (HTTP ${resp.status})`);
        }

        if (window.ToastManager && typeof window.ToastManager.success === "function") {
          window.ToastManager.success("Upload deleted", "The upload has been removed.");
        } else {
          alert("Upload deleted");
        }
        loadPSTHistory();
      } catch (error) {
        const msg = error?.message || String(error);
        if (window.ToastManager && typeof window.ToastManager.error === "function") {
          window.ToastManager.error("Delete failed", msg);
        } else {
          alert("Failed to delete upload: " + msg);
        }
      }
    }

    function viewEmails() {
      // Keep the current context (projectId OR caseId) when navigating.
      if (window.VeriCaseApp && typeof window.VeriCaseApp.gotoCorrespondence === "function") {
        window.VeriCaseApp.gotoCorrespondence();
        return;
      }

      // Fallback: manually preserve whatever context params exist.
      const params =
        window.VeriCaseApp && typeof window.VeriCaseApp.getContextParams === "function"
          ? window.VeriCaseApp.getContextParams()
          : "";
      window.location.href = `correspondence-enterprise.html${params ? "?" + params : ""}`;
    }

    function goToDashboard() {
      VeriCaseApp.gotoDashboard();
    }

    // Initialize
    VeriCaseApp.init().then(() => {
      console.log("VeriCaseApp initialized:", VeriCaseApp.projectId);
      ToastManager.init();
      loadPSTHistory();
      startLiveTracking();
      
      // Show welcome notification
      setTimeout(() => {
        const activeProject = VeriCaseApp.projectId || VeriCaseApp.caseId;
        if (activeProject) {
          ToastManager.info("Ready to Upload", "Drag and drop files or click to browse");
        }
      }, 500);
    });

    // ============ LIVE PROCESSING TRACKER ============
    let liveTrackingInterval = null;
    let activeProcessingFiles = [];

    function startLiveTracking() {
      // Poll every 5 seconds for processing status
      refreshLiveStatus();
      liveTrackingInterval = setInterval(refreshLiveStatus, 5000);
    }

    function stopLiveTracking() {
      if (liveTrackingInterval) {
        clearInterval(liveTrackingInterval);
        liveTrackingInterval = null;
      }
    }

    async function refreshLiveStatus() {
      try {
        const params = new URLSearchParams();
        if (VeriCaseApp.projectId) {
          params.append("project_id", VeriCaseApp.projectId);
        } else if (VeriCaseApp.caseId) {
          params.append("case_id", VeriCaseApp.caseId);
        } else {
          // No active context; nothing to poll.
          activeProcessingFiles = [];
          updateLiveTracker();
          return;
        }
        // Include pending so newly-enqueued jobs show up immediately.
        params.append("status", "queued,pending,processing");
        params.append("page_size", "10");

        const response = await fetch(
          `${apiUrl}/api/correspondence/pst/files?${params}`,
          withAuth({})
        );

        if (!response.ok) return;

        const data = await response.json();
        activeProcessingFiles = data.items?.filter(
          (f) =>
            f.processing_status === "processing" ||
            f.processing_status === "pending" ||
            f.processing_status === "queued"
        ) || [];

        updateLiveTracker();
        
        // Also fetch individual status for more accurate progress
        for (const file of activeProcessingFiles) {
          try {
            const statusResp = await fetch(
              `${apiUrl}/api/correspondence/pst/${file.id}/status`,
              withAuth({})
            );
            if (statusResp.ok) {
              const status = await statusResp.json();
              file.progress_percent = status.progress_percent || 0;
              file.processed_emails = status.processed_emails || 0;
              file.total_emails = status.total_emails || file.total_emails || 0;
              file.current_phase = status.current_phase || "Processing";
            }
          } catch (e) {
            // Ignore individual status errors
          }
        }
        
        updateLiveTracker();
        
        // If something finished, refresh history and show notification
        if (activeProcessingFiles.length !== (window._lastActiveCount || 0)) {
          loadPSTHistory();
          
          // Check if files finished processing
          if ((window._lastActiveCount || 0) > activeProcessingFiles.length) {
            const finishedCount = (window._lastActiveCount || 0) - activeProcessingFiles.length;
            ToastManager.success(
              "Processing Complete",
              `${finishedCount} file${finishedCount > 1 ? 's' : ''} finished processing`
            );
          }
        }
        window._lastActiveCount = activeProcessingFiles.length;

      } catch (error) {
        console.error("Error fetching live status:", error);
      }
    }

    function updateLiveTracker() {
      const tracker = document.getElementById("liveTracker");
      const container = document.getElementById("processingItems");

      if (activeProcessingFiles.length === 0) {
        tracker.classList.remove("active");
        return;
      }

      tracker.classList.add("active");

      container.innerHTML = activeProcessingFiles.map(file => {
        const phase = (file.current_phase || "extracting").toLowerCase();
        const phases = ["uploaded", "extracting", "parsing", "indexing"];
        const phaseIndex = phases.findIndex(p => phase.includes(p));
        const currentPhaseIndex = phaseIndex === -1 ? 1 : phaseIndex;
        const processed = Number(file.processed_emails || 0);
        const total = Number(file.total_emails || 0);
        const progressKnown = total > 0;
        const progressPercent = progressKnown ? Math.min(100, Math.round(file.progress_percent || 0)) : 0;
        const progressClass = progressKnown ? "" : (processed > 0 ? "indeterminate" : "");
        const progressWidth = progressKnown ? progressPercent : (processed > 0 ? 100 : 0);
        const progressText = progressKnown
          ? `${progressPercent}% Complete`
          : (processed > 0 ? "Processing..." : "Preparing...");
        const totalDisplay = progressKnown ? total.toLocaleString() : "?";
        
        return `
          <div class="processing-item">
            <div class="processing-item-main">
              <div class="processing-item-icon">
                <i class="fas fa-envelope"></i>
                <div class="spinner-ring"></div>
              </div>
              <div class="processing-item-details">
                <h4>${escapeHtml(file.filename)}</h4>
                <div class="processing-item-stats">
                  <span><i class="fas fa-envelope-open"></i> <strong>${processed.toLocaleString()}</strong> / ${totalDisplay} emails</span>
                  <span><i class="fas fa-tasks"></i> ${escapeHtml(file.current_phase || "Extracting")}</span>
                  <span><i class="fas fa-clock"></i> ${formatTimeAgo(file.uploaded_at)}</span>
                </div>
              </div>
              <div class="processing-item-progress">
                <div class="progress-bar">
                  <div class="progress-fill ${progressClass}" style="width: ${progressWidth}%"></div>
                </div>
                <div class="progress-text">${progressText}</div>
              </div>
            </div>
            <div class="phase-indicator">
              <div class="phase-step ${currentPhaseIndex >= 0 ? 'complete' : ''} ${currentPhaseIndex === 0 ? 'active' : ''}">
                <div class="phase-icon"><i class="fas fa-cloud-upload-alt"></i></div>
                <span class="phase-label">Uploaded</span>
              </div>
              <div class="phase-step ${currentPhaseIndex >= 1 ? 'complete' : ''} ${currentPhaseIndex === 1 ? 'active' : ''}">
                <div class="phase-icon"><i class="fas fa-file-export"></i></div>
                <span class="phase-label">Extracting</span>
              </div>
              <div class="phase-step ${currentPhaseIndex >= 2 ? 'complete' : ''} ${currentPhaseIndex === 2 ? 'active' : ''}">
                <div class="phase-icon"><i class="fas fa-cogs"></i></div>
                <span class="phase-label">Parsing</span>
              </div>
              <div class="phase-step ${currentPhaseIndex >= 3 ? 'complete' : ''} ${currentPhaseIndex === 3 ? 'active' : ''}">
                <div class="phase-icon"><i class="fas fa-search"></i></div>
                <span class="phase-label">Indexing</span>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    function formatTimeAgo(dateStr) {
      if (!dateStr) return "just now";
      const date = new Date(dateStr);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMins / 60);

      if (diffMins < 1) return "just now";
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      return formatDate(dateStr);
    }
  </script>
</body>

</html>
