<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="build-version" content="2.0.4-<?php echo time(); ?>" />
  <title>VeriCase - Evidence Repository</title>

  <!-- AG-Grid Enterprise CSS (v35.0.0) - Latest with improved SSRM support -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@35.0.0/styles/ag-grid.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@35.0.0/styles/ag-theme-alpine.css" />
  <!-- Custom VeriCase theme extends Alpine -->
  <link rel="stylesheet" href="ag-theme-vericase.css?v=3" />

  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="./assets/fontawesome/css/all.min.css" />

  <!-- VeriCase Design System -->
  <link rel="stylesheet" href="brand-styles.css?v=6" />
  <link rel="stylesheet" href="design-system.css?v=6" />
  <script src="config.js"></script>
  <script src="vericase-ui.js"></script>
  <script src="nav-shell.js"></script>

  <style>
    body {
      background: var(--bg-primary);
      /* Let the shell/content manage scrolling; hiding body overflow can clip the grid entirely. */
      overflow: auto;
    }

    /* When wrapped by nav-shell, make the injected content a proper flex column so the grid can size correctly. */
    .app-content.evidence-page {
      display: flex;
      flex-direction: column;
      min-height: 0;
      padding: 0; /* use full width; page has its own spacing */
    }

    .evidence-layout {
      display: flex;
      /* Fill remaining height under the tabs/toolbar/stats within the shell's content area. */
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    /* Toolbar */
    .toolbar {
      padding: 16px 24px;
      background: white;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .search-container {
      position: relative;
      flex: 1;
      max-width: 400px;
    }

    .search-container input {
      width: 100%;
      padding: 10px 16px 10px 42px;
      border: 2px solid var(--gray-200);
      border-radius: var(--radius-lg);
      font-size: 0.875rem;
      transition: all var(--duration-fast);
      background: var(--gray-50);
    }

    .search-container input:focus {
      outline: none;
      border-color: var(--vericase-teal);
      background: white;
      box-shadow: 0 0 0 3px rgba(var(--vericase-teal-rgb), 0.1);
    }

    .search-container i {
      position: absolute;
      left: 14px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
      pointer-events: none;
      transition: color var(--duration-fast);
    }

    .search-container:focus-within i {
      color: var(--vericase-teal);
    }

    .filter-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-select {
      padding: 10px 32px 10px 14px;
      border: 2px solid var(--gray-200);
      border-radius: var(--radius-lg);
      font-size: 0.8125rem;
      background: white;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236B7280' d='M3 4.5L6 7.5L9 4.5'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      transition: all var(--duration-fast);
    }

    .filter-select:hover {
      border-color: var(--gray-300);
    }

    .filter-select:focus {
      outline: none;
      border-color: var(--vericase-teal);
    }

    .checkbox-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border: 2px solid var(--gray-200);
      border-radius: var(--radius-full);
      font-size: 0.8125rem;
      cursor: pointer;
      transition: all var(--duration-fast);
      -webkit-user-select: none;
      user-select: none;
      background: white;
    }

    .checkbox-pill:hover {
      border-color: var(--gray-300);
    }

    .checkbox-pill.active {
      background: rgba(var(--vericase-teal-rgb), 0.1);
      border-color: var(--vericase-teal);
      color: var(--vericase-teal-dark);
    }

    .checkbox-pill input {
      display: none;
    }

    .toolbar-spacer {
      flex: 1;
    }

    .toolbar-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .selection-info {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 12px;
      background: var(--gray-100);
      border-radius: var(--radius-md);
    }

    .btn-text-sm {
      font-size: 0.75rem;
    }

    #excludeSelectedBtn:not(:disabled) {
      color: #991b1b;
      background: #fef2f2;
      border-color: #fecaca;
    }

    #excludeSelectedBtn:not(:disabled):hover {
      background: #fee2e2;
    }

    /* Stats Bar - VeriCase Branding */
    .stats-bar {
      padding: 12px 24px;
      background: linear-gradient(135deg,
          var(--vericase-teal) 0%,
          var(--vericase-navy) 100%);
      color: white;
      display: flex;
      gap: 32px;
      font-size: 0.8125rem;
      box-shadow: 0 4px 12px rgba(var(--vericase-teal-rgb), 0.2);
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 8px;
      color: rgba(255, 255, 255, 0.85);
    }

    .stat-value {
      font-weight: 700;
      color: white;
      font-size: 0.9375rem;
    }

    /* Category Tabs */
    .category-tabs {
      display: flex;
      gap: 0;
      background: white;
      border-bottom: 1px solid var(--gray-200);
      padding: 0 24px;
    }

    .category-tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 14px 20px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      position: relative;
      transition: all var(--duration-fast);
    }

    .category-tab::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--vericase-teal);
      transform: scaleX(0);
      transition: transform var(--duration-normal) var(--ease-out-expo);
    }

    .category-tab:hover {
      color: var(--text-primary);
    }

    .category-tab.active {
      color: var(--vericase-teal);
    }

    .category-tab.active::after {
      transform: scaleX(1);
    }

    .tab-count {
      background: var(--gray-200);
      color: var(--text-secondary);
      padding: 2px 8px;
      border-radius: var(--radius-full);
      font-size: 0.75rem;
      font-weight: 600;
      transition: all var(--duration-fast);
    }

    .category-tab.active .tab-count {
      background: rgba(var(--vericase-teal-rgb), 0.15);
      color: var(--vericase-teal-dark);
    }

    /* Collections Sidebar */
    .collections-sidebar {
      width: 240px;
      background: white;
      border-right: 1px solid var(--gray-200);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sidebar-section-title {
      font-size: 0.6875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .sidebar-header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
    }

    .auto-categorize-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 0.75rem;
      color: var(--text-secondary);
      -webkit-user-select: none;
      user-select: none;
    }

    .auto-categorize-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
      accent-color: var(--vericase-teal);
    }

    .auto-categorize-toggle .toggle-label {
      font-size: 0.75rem;
    }

    .collection-item.nested {
      padding-left: 32px;
    }

    .collection-item.nested-2 {
      padding-left: 48px;
    }

    .collection-item.nested-3 {
      padding-left: 64px;
    }

    .collection-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 8px 16px;
    }

    .collection-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 0.875rem;
      color: var(--text-secondary);
      transition: all var(--duration-fast);
    }

    .collection-item:hover {
      background: var(--gray-100);
      color: var(--text-primary);
    }

    .collection-item.active {
      background: rgba(var(--vericase-teal-rgb), 0.1);
      color: var(--vericase-teal-dark);
    }

    .collection-item.default-category {
      border-left: 3px solid var(--vericase-teal);
      margin-left: 4px;
    }

    .collection-item.default-category i {
      color: var(--vericase-teal);
    }

    .collection-item i {
      font-size: 1rem;
      width: 20px;
      text-align: center;
      opacity: 0.7;
    }

    .collection-item.active i {
      opacity: 1;
      color: var(--vericase-teal);
    }

    .collection-count {
      margin-left: auto;
      background: var(--gray-200);
      padding: 2px 8px;
      border-radius: var(--radius-full);
      font-size: 0.6875rem;
      font-weight: 600;
    }

    .collection-item.active .collection-count {
      background: rgba(var(--vericase-teal-rgb), 0.2);
      color: var(--vericase-teal-dark);
    }

    /* Grid Container */
    .grid-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
      background: var(--gray-50);
      position: relative;
    }

    .grid-wrapper {
      flex: 1;
      padding: 16px;
      overflow: hidden;
      min-height: 0;
    }

    #evidenceGrid {
      width: 100%;
      height: 100%;
    }

    #evidenceGrid.ag-theme-alpine .ag-root-wrapper {
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-lg);
    }

    #evidenceGrid.ag-theme-alpine .ag-header {
      border-bottom: 2px solid var(--gray-200);
    }

    #evidenceGrid.ag-theme-alpine .ag-header-cell {
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.6875rem;
      letter-spacing: 0.05em;
    }

    #evidenceGrid.ag-theme-alpine .ag-row {
      transition: background-color var(--duration-fast);
    }

    #evidenceGrid.ag-theme-alpine .ag-row:hover {
      background-color: rgba(var(--vericase-teal-rgb), 0.04) !important;
    }

    #evidenceGrid.ag-theme-alpine .ag-row-selected {
      background-color: rgba(var(--vericase-teal-rgb), 0.08) !important;
    }

    /* Grid Cell Renderers */
    .grid-thumbnail {
      width: 36px;
      height: 36px;
      object-fit: cover;
      border-radius: var(--radius-sm);
      background: var(--gray-100);
    }

    .grid-file-icon {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--gray-100);
      border-radius: var(--radius-sm);
      font-size: 1rem;
    }

    .grid-file-icon.pdf {
      background: #fee2e2;
      color: #dc2626;
    }

    .grid-file-icon.word {
      background: #dbeafe;
      color: #2563eb;
    }

    .grid-file-icon.excel {
      background: #d1fae5;
      color: #059669;
    }

    .grid-file-icon.image {
      background: #ede9fe;
      color: #7c3aed;
    }

    .grid-file-icon.email {
      background: #fef3c7;
      color: #d97706;
    }

    .file-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .file-name {
      font-weight: 500;
      color: var(--text-primary);
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      word-break: break-word;
    }

    .file-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: var(--radius-full);
      font-size: 0.6875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .status-processed {
      background: #d1fae5;
      color: #065f46;
    }

    .status-processing {
      background: #fef3c7;
      color: #92400e;
    }

    .status-pending {
      background: #e0e7ff;
      color: #3730a3;
    }

    .status-ready {
      background: #d1fae5;
      color: #065f46;
    }

    .status-completed {
      background: #d1fae5;
      color: #065f46;
    }

    .status-error {
      background: #fee2e2;
      color: #991b1b;
    }

    .star-btn {
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--gray-300);
      font-size: 1rem;
      padding: 4px;
      transition: all var(--duration-fast);
    }

    .star-btn:hover {
      color: var(--warning);
      transform: scale(1.15);
    }

    .star-btn.starred {
      color: var(--warning);
    }

    /* Detail Panel */
    .detail-panel {
      width: 420px;
      background: white;
      border-left: 1px solid var(--gray-200);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      transform: translateX(100%);
      opacity: 0;
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: 50;
      box-shadow: -8px 0 30px rgba(0, 0, 0, 0.1);
      transition:
        transform var(--duration-slow) var(--ease-out-expo),
        opacity var(--duration-normal);
    }

    .detail-panel.open {
      transform: translateX(0);
      opacity: 1;
    }

    .detail-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--gray-50);
    }

    .detail-header h3 {
      font-size: 0.9375rem;
      font-weight: 600;
    }

    .detail-header-actions {
      display: flex;
      gap: 8px;
    }

    .close-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--text-muted);
      transition: all var(--duration-fast);
    }

    .close-btn:hover {
      background: var(--gray-200);
      color: var(--text-primary);
    }

    .detail-body {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .vericase-suggestions-panel {
      border-top: 1px solid var(--gray-200);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: var(--gray-50);
    }

    .suggestions-panel-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .suggestions-panel-header h4 {
      margin: 0;
      font-size: 0.875rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
    }

    .suggestions-panel-header i {
      color: var(--vericase-teal);
    }

    .suggestions-panel-body {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .suggestions-empty-state,
    .suggestions-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 32px 16px;
      text-align: center;
      color: var(--text-muted);
      gap: 8px;
    }

    .suggestions-empty-state i,
    .suggestions-loading i {
      font-size: 1.5rem;
      opacity: 0.5;
    }

    .suggestions-empty-state p,
    .suggestions-loading span {
      font-size: 0.8125rem;
    }

    .suggestion-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .suggestion-group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .suggestion-group-header i {
      color: var(--vericase-teal);
      font-size: 0.6875rem;
    }

    .suggestion-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .suggestion-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px;
      background: white;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      transition: all var(--duration-fast);
    }

    .suggestion-item:hover {
      border-color: var(--vericase-teal);
      box-shadow: 0 2px 8px rgba(31, 111, 120, 0.1);
    }

    .suggestion-item-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .suggestion-item-title {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .suggestion-item-title i {
      color: var(--vericase-teal);
      font-size: 0.75rem;
    }

    .suggestion-item-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .suggestion-item-meta i {
      font-size: 0.6875rem;
    }

    .suggestion-item-context {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-top: 4px;
      font-style: italic;
    }

    .collab-panel {
      border-top: 1px solid var(--gray-200);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .collab-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .collab-panel-header h4 {
      margin: 0;
      font-size: 0.875rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .collab-panel-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .lane-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .lane-tab {
      padding: 6px 12px;
      font-size: 0.75rem;
      font-weight: 600;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      background: white;
      color: var(--text-muted);
      cursor: pointer;
      transition: all var(--duration-fast);
    }

    .lane-tab.active {
      background: var(--vericase-teal);
      border-color: var(--vericase-teal);
      color: white;
    }

    .collab-thread {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 220px;
      overflow-y: auto;
    }

    .collab-section-title {
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin: 6px 0;
    }

    .collab-comment {
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      padding: 10px 12px;
      font-size: 0.8125rem;
    }

    .collab-comment.reply {
      margin-left: 18px;
      border-left: 3px solid var(--vericase-teal);
    }

    .collab-comment-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .collab-input {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .collab-input textarea {
      flex: 1;
      min-height: 70px;
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      padding: 8px 10px;
      font-size: 0.8125rem;
      resize: vertical;
    }

    .collab-input textarea:focus {
      outline: none;
      border-color: var(--vericase-teal);
      box-shadow: 0 0 0 2px rgba(var(--vericase-teal-rgb), 0.15);
    }

    .collab-empty {
      border: 1px dashed var(--gray-200);
      border-radius: var(--radius-md);
      padding: 12px;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8125rem;
    }

    .lane-badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: var(--radius-md);
      font-size: 0.625rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      background: var(--gray-100);
      color: var(--text-muted);
    }

    .lane-badge.core {
      background: rgba(var(--vericase-teal-rgb), 0.12);
      color: #0f766e;
    }

    .lane-badge.counsel {
      background: rgba(59, 130, 246, 0.12);
      color: #1d4ed8;
    }

    .lane-badge.expert {
      background: rgba(245, 158, 11, 0.16);
      color: #b45309;
    }

    .collab-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .collab-toggle input {
      width: 14px;
      height: 14px;
    }

    /* Preview Section */
    .preview-section {
      background: var(--gray-900);
      min-height: 200px;
      max-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .preview-section img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    .preview-section iframe {
      width: 100%;
      height: 280px;
      border: none;
    }

    .preview-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      color: var(--gray-500);
    }

    .preview-placeholder i {
      font-size: 2.5rem;
    }

    .preview-expand-btn {
      position: absolute;
      bottom: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: var(--radius-md);
      font-size: 0.75rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all var(--duration-fast);
    }

    .preview-expand-btn:hover {
      background: rgba(0, 0, 0, 0.8);
    }

    /* Metadata Content */
    .metadata-content {
      padding: 16px 20px;
    }

    .detail-section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--gray-100);
    }

    .detail-section:last-child {
      border-bottom: none;
    }

    .detail-section-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }

    .detail-section-header i {
      color: var(--vericase-teal);
      font-size: 0.875rem;
    }

    .detail-section-header h4 {
      font-size: 0.8125rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .detail-label {
      font-size: 0.6875rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
    }

    .detail-value {
      font-size: 0.875rem;
      color: var(--text-primary);
    }

    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: var(--gray-100);
      border-radius: var(--radius-full);
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .tag-blue {
      background: #dbeafe;
      color: #1e40af;
    }

    .tag-teal {
      background: rgba(var(--vericase-teal-rgb), 0.15);
      color: var(--vericase-teal-dark);
    }

    .tag-purple {
      background: #ede9fe;
      color: #5b21b6;
    }

    .tag-yellow {
      background: #fef3c7;
      color: #92400e;
    }

    /* Detail Actions */
    .detail-actions {
      padding: 16px 20px;
      border-top: 1px solid var(--gray-200);
      display: flex;
      gap: 12px;
      background: var(--gray-50);
    }

    .detail-actions .btn {
      flex: 1;
    }

    /* Full-Screen Preview Modal */
    .preview-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: var(--z-modal);
      display: flex;
      flex-direction: column;
      opacity: 0;
      visibility: hidden;
      transition:
        opacity var(--duration-normal),
        visibility var(--duration-normal);
    }

    .preview-modal.active {
      opacity: 1;
      visibility: visible;
    }

    .preview-modal-header {
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: white;
    }

    .preview-modal-title {
      font-weight: 500;
      max-width: 70%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .preview-modal-actions {
      display: flex;
      gap: 8px;
    }

    .preview-modal-actions .btn {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .preview-modal-actions .btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .preview-modal-body {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      overflow: auto;
    }

    .preview-modal-content {
      max-width: 100%;
      max-height: 100%;
    }

    .preview-modal-content img {
      max-width: 100%;
      max-height: calc(100vh - 150px);
      object-fit: contain;
    }

    .preview-modal-content iframe {
      width: 90vw;
      height: calc(100vh - 150px);
      border: none;
      background: white;
      border-radius: var(--radius-lg);
    }

    .preview-modal-content object {
      width: 90vw;
      height: calc(100vh - 150px);
      border: none;
      background: white;
      border-radius: var(--radius-lg);
    }

    .preview-section object {
      width: 100%;
      height: 100%;
      min-height: 400px;
      border: none;
      background: white;
      border-radius: var(--radius-md);
    }

    .preview-modal-content pre {
      background: var(--gray-900);
      color: var(--gray-300);
      padding: 24px;
      border-radius: var(--radius-lg);
      max-width: 90vw;
      max-height: calc(100vh - 150px);
      overflow: auto;
      font-family: var(--font-mono);
      font-size: 0.8125rem;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Settings Modal */
    .settings-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: var(--z-modal);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }

    .settings-modal {
      background: white;
      border-radius: var(--radius-lg);
      width: 100%;
      max-width: 600px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
    }

    .settings-modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .settings-modal-header h3 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--vericase-navy);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .settings-modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .settings-modal-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--gray-200);
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section:last-child {
      margin-bottom: 0;
    }

    .settings-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .settings-section-header h4 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .settings-section-header h4 i {
      color: var(--vericase-teal);
    }

    .settings-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .settings-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      margin-bottom: 8px;
    }

    .settings-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--vericase-teal);
    }

    .patterns-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .pattern-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      font-size: 0.8125rem;
    }

    .pattern-item.readonly {
      background: var(--gray-100);
      color: var(--text-muted);
    }

    .pattern-text {
      flex: 1;
      font-family: var(--font-mono);
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .pattern-category {
      padding: 2px 8px;
      background: rgba(var(--vericase-teal-rgb), 0.1);
      color: var(--vericase-teal-dark);
      border-radius: 999px;
      font-size: 0.7rem;
      font-weight: 500;
    }

    .pattern-count {
      padding: 2px 6px;
      background: var(--gray-200);
      color: var(--text-muted);
      border-radius: 999px;
      font-size: 0.65rem;
      font-weight: 600;
    }

    .pattern-item .btn-delete {
      padding: 4px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
    }

    .pattern-item .btn-delete:hover {
      background: rgba(220, 38, 38, 0.1);
      color: #dc2626;
    }

    .patterns-empty {
      text-align: center;
      padding: 16px;
      color: var(--text-muted);
      font-size: 0.8125rem;
    }

    .category-settings-btn {
      padding: 4px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 0.875rem;
    }

    .category-settings-btn:hover {
      color: var(--vericase-teal);
      background: rgba(var(--vericase-teal-rgb), 0.1);
    }

    .settings-modal-overlay.hidden {
      display: none !important;
    }

    /* Link Cards */
    .link-card {
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      padding: 12px;
      margin-bottom: 8px;
      transition: all var(--duration-fast);
    }

    .link-card:hover {
      border-color: var(--vericase-teal);
      background: white;
    }

    .link-card-title {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .link-card-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* GPS Link */
    .gps-map-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--vericase-blue);
      text-decoration: none;
      font-size: 0.8125rem;
    }

    .gps-map-link:hover {
      text-decoration: underline;
    }

    /* ============================================
       INTELLIGENCE LAYER STYLES
       ============================================ */
    
    /* AI Confidence Badge */
    .ai-confidence-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
      min-width: 45px;
      justify-content: center;
    }
    
    .ai-confidence-badge.high {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }
    
    .ai-confidence-badge.medium {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
    }
    
    .ai-confidence-badge.low {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }
    
    .ai-confidence-badge.none {
      background: var(--gray-200);
      color: var(--text-muted);
    }
    
    /* Sentiment Indicator */
    .sentiment-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.75rem;
    }
    
    .sentiment-indicator.positive {
      color: #10b981;
    }
    
    .sentiment-indicator.neutral {
      color: var(--text-muted);
    }
    
    .sentiment-indicator.negative {
      color: #ef4444;
    }
    
    .sentiment-indicator.escalation {
      color: #dc2626;
      font-weight: 600;
    }
    
    /* Entity Tags */
    .entity-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-width: 200px;
    }
    
    .entity-tag {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    
    .entity-tag.person {
      background: rgba(59, 130, 246, 0.15);
      color: #3b82f6;
    }
    
    .entity-tag.organization {
      background: rgba(139, 92, 246, 0.15);
      color: #8b5cf6;
    }
    
    .entity-tag.date {
      background: rgba(249, 115, 22, 0.15);
      color: #f97316;
    }
    
    .entity-tag.money {
      background: rgba(16, 185, 129, 0.15);
      color: #10b981;
    }
    
    .entity-tag.location {
      background: rgba(236, 72, 153, 0.15);
      color: #ec4899;
    }
    
    /* Auto Tags Display */
    .auto-tags-display {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    
    .auto-tag {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      background: rgba(31, 111, 120, 0.1);
      color: var(--vericase-teal-dark);
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 500;
    }
    
    .auto-tag i {
      margin-right: 4px;
      font-size: 0.6rem;
    }
    
    /* AI Analyzed Indicator */
    .ai-analyzed-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.75rem;
    }
    
    .ai-analyzed-indicator.analyzed {
      color: var(--vericase-teal);
    }
    
    .ai-analyzed-indicator.pending {
      color: var(--text-muted);
    }
    
    /* Intelligence Panel */
    .intelligence-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 420px;
      height: 100vh;
      background: white;
      border-left: 1px solid var(--gray-200);
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1100;
      display: flex;
      flex-direction: column;
    }
    
    .intelligence-panel.open {
      transform: translateX(0);
    }
    
    .intelligence-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--gray-200);
      background: linear-gradient(135deg, var(--vericase-teal) 0%, var(--vericase-teal-dark) 100%);
      color: white;
    }
    
    .intelligence-panel-header h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .intelligence-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    /* AI Chat Interface */
    .ai-chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    .ai-chat-messages {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-bottom: 16px;
    }
    
    .ai-chat-message {
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 0.875rem;
      line-height: 1.5;
      max-width: 90%;
    }
    
    .ai-chat-message.user {
      background: var(--vericase-teal);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    
    .ai-chat-message.assistant {
      background: var(--gray-100);
      color: var(--text-primary);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }
    
    .ai-chat-message.system {
      background: rgba(249, 115, 22, 0.1);
      color: #c2410c;
      font-size: 0.8rem;
      text-align: center;
      align-self: center;
    }
    
    .ai-chat-input-container {
      display: flex;
      gap: 8px;
      padding-top: 16px;
      border-top: 1px solid var(--gray-200);
    }
    
    .ai-chat-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid var(--gray-200);
      border-radius: var(--radius-lg);
      font-size: 0.875rem;
      resize: none;
      min-height: 44px;
      max-height: 120px;
    }
    
    .ai-chat-input:focus {
      outline: none;
      border-color: var(--vericase-teal);
    }
    
    .ai-chat-send-btn {
      padding: 12px 16px;
      background: var(--vericase-teal);
      color: white;
      border: none;
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: all var(--duration-fast);
    }
    
    .ai-chat-send-btn:hover {
      background: var(--vericase-teal-dark);
    }
    
    .ai-chat-send-btn:disabled {
      background: var(--gray-300);
      cursor: not-allowed;
    }
    
    /* Semantic Search Results */
    .semantic-search-results {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }
    
    .semantic-result-item {
      padding: 12px;
      background: var(--gray-50);
      border: 1px solid var(--gray-200);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--duration-fast);
    }
    
    .semantic-result-item:hover {
      border-color: var(--vericase-teal);
      background: white;
    }
    
    .semantic-result-title {
      font-weight: 600;
      font-size: 0.875rem;
      color: var(--text-primary);
      margin-bottom: 4px;
    }
    
    .semantic-result-snippet {
      font-size: 0.8rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }
    
    .semantic-result-score {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.7rem;
      color: var(--vericase-teal);
      margin-top: 8px;
    }
    
    /* AI Query Suggestions */
    .ai-query-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .ai-query-suggestion {
      padding: 6px 12px;
      background: rgba(31, 111, 120, 0.08);
      border: 1px solid rgba(31, 111, 120, 0.2);
      border-radius: 20px;
      font-size: 0.75rem;
      color: var(--vericase-teal-dark);
      cursor: pointer;
      transition: all var(--duration-fast);
    }
    
    .ai-query-suggestion:hover {
      background: rgba(31, 111, 120, 0.15);
      border-color: var(--vericase-teal);
    }
    
    /* Intelligence Stats Card */
    .intelligence-stats-card {
      background: linear-gradient(135deg, rgba(31, 111, 120, 0.05) 0%, rgba(31, 111, 120, 0.1) 100%);
      border: 1px solid rgba(31, 111, 120, 0.2);
      border-radius: var(--radius-lg);
      padding: 16px;
      margin-bottom: 20px;
    }
    
    .intelligence-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    
    .intelligence-stat {
      text-align: center;
    }
    
    .intelligence-stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--vericase-teal-dark);
    }
    
    .intelligence-stat-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    /* Toolbar AI Button */
    .btn-ai {
      background: linear-gradient(135deg, var(--vericase-teal) 0%, #0d9488 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: var(--radius-md);
      font-weight: 600;
      font-size: 0.8125rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: all var(--duration-fast);
      box-shadow: 0 2px 8px rgba(31, 111, 120, 0.3);
    }
    
    .btn-ai:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(31, 111, 120, 0.4);
    }
    
    .btn-ai i {
      font-size: 0.875rem;
    }
    
    .btn-ai .ai-pulse {
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      animation: ai-pulse 2s infinite;
    }
    
    @keyframes ai-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }
    
    .ai-pulse-large {
      width: 48px;
      height: 48px;
      margin: 0 auto;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--vericase-teal), #8b5cf6);
      animation: ai-pulse-large 1.5s ease-in-out infinite;
    }
    
    @keyframes ai-pulse-large {
      0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 0 0 0 rgba(31, 111, 120, 0.4);
      }
      50% { 
        transform: scale(1.1); 
        box-shadow: 0 0 20px 10px rgba(31, 111, 120, 0);
      }
    }

    /* Responsive */
    @media (max-width: 1200px) {
      .collections-sidebar {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }

      .search-container {
        max-width: 100%;
      }

      .filter-group {
        flex-wrap: wrap;
      }

      .detail-panel {
        width: 100%;
      }
    }
  </style>
  <!-- AG-Grid Enterprise Script (v35.0.0) -->
  <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@35.0.0/dist/ag-grid-enterprise.min.js"></script>
</head>

<body class="preload">
  <!-- Category Tabs -->
  <div class="category-tabs">
    <button class="category-tab active" data-category="documents" id="tabDocuments">
      <i class="fas fa-file-alt"></i> Documents
      <span class="tab-count" id="docCount">0</span>
    </button>
    <button class="category-tab" data-category="images" id="tabImages">
      <i class="fas fa-image"></i> Images & Media
      <span class="tab-count" id="imgCount">0</span>
    </button>
    <button class="category-tab" data-category="all" id="tabAll">
      <i class="fas fa-layer-group"></i> All Files
      <span class="tab-count" id="allCount">0</span>
    </button>
  </div>

  <!-- Toolbar -->
  <div class="toolbar">
    <div class="search-container">
      <i class="fas fa-search"></i>
      <input type="text" id="searchInput" placeholder="Search evidence by name, content, or tags..." />
    </div>

    <div class="filter-group">
      <select class="filter-select" id="fileTypeFilter" title="File type filter" aria-label="File type filter">
        <option value="">All File Types</option>
        <option value="pdf">PDF Documents</option>
        <option value="word">Word Documents</option>
        <option value="excel">Spreadsheets</option>
        <option value="powerpoint">Presentations</option>
        <option value="text">Text Files</option>
        <option value="image">Images</option>
        <option value="other">Other</option>
      </select>

      <select class="filter-select" id="statusFilter" title="Status filter" aria-label="Status filter">
        <option value="">All Status</option>
        <option value="ready">Complete (text extracted)</option>
        <option value="processed">Processed (metadata only)</option>
        <option value="processing">Processing</option>
        <option value="pending">Pending</option>
        <option value="error">Error</option>
      </select>

      <label class="checkbox-pill" id="unassignedPill">
        <input type="checkbox" id="unassignedFilter" />
        <i class="fas fa-inbox"></i>
        Unassigned
      </label>

      <label class="checkbox-pill" id="starredPill">
        <input type="checkbox" id="starredFilter" />
        <i class="fas fa-star"></i>
        Starred
      </label>
    </div>

    <div class="toolbar-spacer"></div>

    <!-- Selection Actions -->
    <div class="toolbar-actions" style="margin-right: 12px;">
      <span class="selection-info" style="font-size: 0.8125rem; color: var(--text-secondary); margin-right: 8px;">
        <span id="selectedCount">0</span> selected
      </span>
      <button class="btn btn-ghost" id="excludeSelectedBtn" title="Mark selected as excluded" disabled onclick="markAsExcluded()">
        <i class="fas fa-ban"></i>
        <span class="btn-text-sm">Exclude</span>
      </button>
      <button class="btn btn-ghost" id="deleteSelectedBtn" title="Delete selected items" disabled onclick="deleteSelectedItems()">
        <i class="fas fa-trash"></i>
      </button>
    </div>

    <div class="toolbar-actions">
      <button class="btn btn-ghost" id="columnsBtn" title="Columns">
        <i class="fas fa-columns"></i>
      </button>
      <button class="btn btn-ghost" id="saveGridBtn" title="Save layout">
        <i class="fas fa-save"></i>
      </button>
      <button class="btn btn-ghost" id="resetGridBtn" title="Reset layout">
        <i class="fas fa-undo"></i>
      </button>
      <button class="btn btn-ghost" id="autofitBtn" title="Auto-fit columns">
        <i class="fas fa-arrows-alt-h"></i>
      </button>
    </div>

    <input type="file" id="fileInput" multiple style="display: none" />
    <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none" />
    <button class="btn btn-vericase" id="uploadBtn">
      <i class="fas fa-upload"></i>
      <span class="btn-text">Upload Evidence</span>
    </button>
    <button class="btn btn-ghost" id="uploadFolderBtn" title="Upload a folder">
      <i class="fas fa-folder-open"></i>
      <span class="btn-text-sm">Folder</span>
    </button>

    <button class="btn btn-ghost" id="rescanKeywordsBtn" title="Rescan correspondence + evidence for configured keywords">
      <i class="fas fa-tags"></i>
      <span class="btn-text-sm">Rescan</span>
    </button>

    <button class="btn btn-ghost" id="refreshBtn" title="Refresh">
      <i class="fas fa-sync-alt"></i>
    </button>

    <!-- VeriCase Intelligence Button -->
    <button class="btn-ai" id="aiIntelligenceBtn" title="VeriCase Intelligence - Natural language search and analysis">
      <i class="fas fa-brain"></i>
      <span>VeriCase Intelligence</span>
      <span class="ai-pulse"></span>
    </button>

    <!-- Case Insights Button -->
    <button class="btn-secondary" id="caseInsightsBtn" title="Generate case insights" onclick="openCaseInsights()">
      <i class="fas fa-lightbulb" style="color: #fbbf24;"></i>
      <span>Case Insights</span>
    </button>

    <!-- Analytics Charts Dropdown -->
    <div class="dropdown" style="position: relative; display: inline-block;">
      <button class="btn-secondary" id="chartsDropdownBtn" title="Create analytics charts from data">
        <i class="fas fa-chart-bar"></i>
        <span>Charts</span>
        <i class="fas fa-caret-down" style="margin-left: 4px; font-size: 0.75rem;"></i>
      </button>
      <div class="dropdown-menu chart-dropdown" id="chartsDropdownMenu" style="display: none; position: absolute; right: 0; top: 100%; z-index: 1000; min-width: 220px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 8px 16px rgba(0,0,0,0.2); margin-top: 4px;">
        <div class="dropdown-header" style="padding: 8px 12px; font-weight: 600; color: var(--text-secondary); font-size: 0.75rem; text-transform: uppercase; border-bottom: 1px solid var(--border-color);">
          Document Analytics
        </div>
        <button class="dropdown-item" onclick="createChart('category-pie')" style="display: flex; align-items: center; width: 100%; padding: 10px 12px; border: none; background: transparent; color: var(--text-primary); text-align: left; cursor: pointer;">
          <i class="fas fa-pie-chart" style="width: 20px; color: var(--vericase-teal);"></i>
          <span>Category Distribution</span>
        </button>
        <button class="dropdown-item" onclick="createChart('type-bar')" style="display: flex; align-items: center; width: 100%; padding: 10px 12px; border: none; background: transparent; color: var(--text-primary); text-align: left; cursor: pointer;">
          <i class="fas fa-chart-bar" style="width: 20px; color: var(--vericase-teal);"></i>
          <span>File Type Breakdown</span>
        </button>
        <button class="dropdown-item" onclick="createChart('timeline')" style="display: flex; align-items: center; width: 100%; padding: 10px 12px; border: none; background: transparent; color: var(--text-primary); text-align: left; cursor: pointer;">
          <i class="fas fa-chart-line" style="width: 20px; color: var(--vericase-teal);"></i>
          <span>Document Timeline</span>
        </button>
        <div class="dropdown-divider" style="height: 1px; background: var(--border-color); margin: 4px 0;"></div>
        <div class="dropdown-header" style="padding: 8px 12px; font-weight: 600; color: var(--text-secondary); font-size: 0.75rem; text-transform: uppercase; border-bottom: 1px solid var(--border-color);">
          AI Analysis
        </div>
        <button class="dropdown-item" onclick="createChart('confidence-histogram')" style="display: flex; align-items: center; width: 100%; padding: 10px 12px; border: none; background: transparent; color: var(--text-primary); text-align: left; cursor: pointer;">
          <i class="fas fa-brain" style="width: 20px; color: #fbbf24;"></i>
          <span>AI Confidence Scores</span>
        </button>
        <button class="dropdown-item" onclick="createChart('stakeholder-network')" style="display: flex; align-items: center; width: 100%; padding: 10px 12px; border: none; background: transparent; color: var(--text-primary); text-align: left; cursor: pointer;">
          <i class="fas fa-project-diagram" style="width: 20px; color: #8b5cf6;"></i>
          <span>Stakeholder Network</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Stats Bar -->
  <div class="stats-bar">
    <div class="stat-item">
      <i class="fas fa-archive"></i>
      <span class="stat-value" id="totalCount"></span>
      <span>Total Items</span>
    </div>
    <div class="stat-item">
      <i class="fas fa-inbox"></i>
      <span class="stat-value" id="unassignedCount"></span>
      <span>Unassigned</span>
    </div>
    <div class="stat-item">
      <i class="fas fa-link"></i>
      <span class="stat-value" id="linkedCount"></span>
      <span>With Links</span>
    </div>
    <div class="stat-item">
      <i class="fas fa-clock"></i>
      <span class="stat-value" id="recentCount"></span>
      <span>Recent (7d)</span>
    </div>
  </div>

  <!-- Main Content -->
  <div class="evidence-layout">
    <!-- Collections Sidebar -->
    <div class="collections-sidebar">
      <div class="sidebar-header">
      <div class="sidebar-section-title">Collections</div>
        <div class="sidebar-header-actions">
          <label class="auto-categorize-toggle" title="Enable intelligent auto-categorization">
            <input type="checkbox" id="autoCategorizeToggle" />
            <span class="toggle-label">Auto-categorize</span>
          </label>
          <button type="button" class="category-settings-btn" onclick="openCategorySettings()" title="Auto-categorization settings">
            <i class="fas fa-cog"></i>
          </button>
          <button type="button" class="btn btn-sm btn-ghost" id="createSubfolderBtn" title="Create Subfolder">
            <i class="fas fa-plus"></i>
          </button>
        </div>
      </div>
      <div class="collection-list" id="collectionList">
        <div class="collection-item active" data-id="">
          <i class="fas fa-folder"></i>
          All Evidence
        </div>
      </div>
    </div>

    <!-- Grid Container -->
    <div class="grid-container">
      <div class="grid-wrapper">
        <div id="evidenceGrid" class="ag-theme-alpine ag-theme-vericase"></div>
      </div>

      <!-- Detail Panel -->
      <div class="detail-panel" id="detailPanel">
        <div class="detail-header">
          <h3>Evidence Details</h3>
          <div class="detail-header-actions">
            <button class="btn btn-ghost btn-icon btn-sm" id="extractMetadataBtn" title="Extract Metadata">
              <i class="fas fa-magnifying-glass"></i>
            </button>
            <button class="close-btn" id="closeDetailBtn" title="Close" type="button" onclick="hideDetail()">
              <i class="fas fa-times"></i>
            </button>
          </div>
        </div>
        <div class="detail-body" id="detailBody">
          <div class="preview-section" id="previewSection">
            <div class="preview-placeholder">
              <i class="fas fa-file"></i>
              <span>Select an item to preview</span>
            </div>
          </div>
          <div class="metadata-content" id="metadataContent">
            <!-- Populated dynamically -->
          </div>
          <div class="vericase-suggestions-panel" id="vericaseSuggestionsPanel">
            <div class="suggestions-panel-header">
              <h4><i class="fas fa-lightbulb"></i> VeriCase Suggestions</h4>
            </div>
            <div class="suggestions-panel-body" id="vericaseSuggestionsBody">
              <div class="suggestions-empty-state">
                <i class="fas fa-lightbulb"></i>
                <p>Select an evidence item to see suggestions</p>
              </div>
            </div>
          </div>
          <div class="collab-panel" id="evidenceCollabPanel">
            <div class="collab-panel-header">
              <h4><i class="fas fa-comments"></i> Evidence Notes</h4>
              <div class="collab-panel-controls">
                <label class="collab-toggle">
                  <input type="checkbox" id="includeLinkedNotes" onchange="toggleLinkedNotes()">
                  Include claim-linked notes
                </label>
                <div class="lane-tabs" id="evidenceLaneTabs">
                  <button class="lane-tab active" data-lane="core" onclick="setEvidenceLane('core')">Core</button>
                  <button class="lane-tab" data-lane="counsel" onclick="setEvidenceLane('counsel')">Counsel</button>
                  <button class="lane-tab" data-lane="expert" onclick="setEvidenceLane('expert')">Expert</button>
                </div>
              </div>
            </div>
            <div class="collab-thread" id="evidenceCommentThread">
              <div class="collab-empty">Select an item to view notes.</div>
            </div>
            <div class="collab-input">
              <textarea id="evidenceCommentInput" placeholder="Add a note for this evidence item..."></textarea>
              <button class="btn btn-vericase btn-sm" id="evidenceCommentSend" onclick="postEvidenceNote()" title="Send note" aria-label="Send note">
                <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </div>
        </div>
        <div class="detail-actions">
          <button class="btn btn-ghost" id="viewItemBtn">
            <i class="fas fa-eye"></i> View
          </button>
          <button class="btn btn-vericase" id="downloadBtn">
            <i class="fas fa-download"></i> Download
          </button>
          <button class="btn btn-ghost" id="previewFullBtn">
            <i class="fas fa-expand"></i> Full Preview
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- AI Intelligence Panel -->
  <div class="intelligence-panel" id="intelligencePanel">
    <div class="intelligence-panel-header">
      <h3><i class="fas fa-brain"></i> VeriCase Intelligence</h3>
      <button class="btn btn-ghost" onclick="closeIntelligencePanel()" style="color: white; padding: 4px 8px;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="intelligence-panel-content">
      <!-- Intelligence Stats -->
      <div class="intelligence-stats-card">
        <div class="intelligence-stats-grid">
          <div class="intelligence-stat">
            <div class="intelligence-stat-value" id="aiAnalyzedCount">0</div>
            <div class="intelligence-stat-label">Analyzed</div>
          </div>
          <div class="intelligence-stat">
            <div class="intelligence-stat-value" id="entitiesExtracted">0</div>
            <div class="intelligence-stat-label">Entities Found</div>
          </div>
          <div class="intelligence-stat">
            <div class="intelligence-stat-value" id="avgConfidence"></div>
            <div class="intelligence-stat-label">Avg. Confidence</div>
          </div>
          <div class="intelligence-stat">
            <div class="intelligence-stat-value" id="escalationsDetected">0</div>
            <div class="intelligence-stat-label">Escalations</div>
          </div>
        </div>
      </div>
      
      <!-- Query Suggestions -->
      <div style="margin-bottom: 16px;">
        <div style="font-size: 0.75rem; font-weight: 600; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">
          Try asking:
        </div>
        <div class="ai-query-suggestions">
          <button class="ai-query-suggestion" onclick="executeAIQuery('Show documents from the contractor')">
            Contractor docs
          </button>
          <button class="ai-query-suggestion" onclick="executeAIQuery('Find emails about delays')">
            Delay emails
          </button>
          <button class="ai-query-suggestion" onclick="executeAIQuery('Group by document type')">
            Group by type
          </button>
          <button class="ai-query-suggestion" onclick="executeAIQuery('Show escalation emails')">
            Escalations
          </button>
          <button class="ai-query-suggestion" onclick="executeAIQuery('Find payment-related documents')">
            Payments
          </button>
          <button class="ai-query-suggestion" onclick="executeAIQuery('Show high-confidence items')">
            High confidence
          </button>
        </div>
      </div>
      
      <!-- AI Chat Interface -->
      <div class="ai-chat-container">
        <div class="ai-chat-messages" id="aiChatMessages">
          <div class="ai-chat-message assistant">
            <strong>VeriCase AI</strong><br>
            I can help you find, filter, and analyze evidence. Ask me anything like:
            <ul style="margin: 8px 0 0 16px; padding: 0;">
              <li>"Show me all PDFs from June 2024"</li>
              <li>"Find documents mentioning delay claims"</li>
              <li>"Group evidence by stakeholder"</li>
              <li>"What documents reference Drawing 001?"</li>
            </ul>
          </div>
        </div>
        <div class="ai-chat-input-container">
          <textarea 
            class="ai-chat-input" 
            id="aiChatInput" 
            placeholder="Ask me to find, filter, or analyze evidence..."
            rows="1"
            onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); sendAIQuery(); }"
          ></textarea>
          <button class="ai-chat-send-btn" onclick="sendAIQuery()" id="aiSendBtn">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
      
      <!-- Semantic Search Results (populated dynamically) -->
      <div class="semantic-search-results" id="semanticSearchResults" style="display: none;">
        <!-- Results appear here -->
      </div>
    </div>
  </div>

  <!-- Full-Screen Preview Modal -->
  <div class="preview-modal" id="previewModal">
    <div class="preview-modal-header">
      <div class="preview-modal-title" id="previewModalTitle">
        File Preview
      </div>
      <div class="preview-modal-actions">
        <button class="btn btn-sm" id="modalDownloadBtn">
          <i class="fas fa-download"></i> Download
        </button>
        <button class="btn btn-sm" id="closePreviewModal">
          <i class="fas fa-times"></i> Close
        </button>
      </div>
    </div>
    <div class="preview-modal-body">
      <div class="preview-modal-content" id="previewModalContent">
        <!-- Populated dynamically -->
      </div>
    </div>
  </div>

  <!-- Auto-Categorization Settings Modal -->
  <div class="settings-modal-overlay hidden" id="categorySettingsModal">
    <div class="settings-modal">
      <div class="settings-modal-header">
        <h3><i class="fas fa-cog"></i> Auto-Categorization Settings</h3>
        <button type="button" class="btn btn-ghost btn-sm" onclick="closeCategorySettings()" title="Close settings">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="settings-modal-body">
        <!-- Learning Toggle -->
        <div class="settings-section">
          <div class="settings-section-header">
            <h4><i class="fas fa-brain"></i> Learning</h4>
          </div>
          <label class="settings-toggle">
            <input type="checkbox" id="learningEnabledToggle" checked />
            <span>Learn from my categorizations</span>
          </label>
          <p class="settings-hint">When enabled, the system learns patterns from files you categorize to improve future suggestions.</p>
        </div>

        <!-- Custom Patterns -->
        <div class="settings-section">
          <div class="settings-section-header">
            <h4><i class="fas fa-filter"></i> Custom Patterns</h4>
            <button type="button" class="btn btn-sm btn-vericase" onclick="addCustomPattern()" title="Add custom pattern">
              <i class="fas fa-plus"></i> Add
            </button>
          </div>
          <p class="settings-hint">Define your own patterns to match filenames. Use regex syntax (e.g., "report.*2024" matches "report_jan_2024").</p>
          <div class="patterns-list" id="customPatternsList">
            <!-- Populated dynamically -->
          </div>
        </div>

        <!-- Learned Patterns -->
        <div class="settings-section">
          <div class="settings-section-header">
            <h4><i class="fas fa-graduation-cap"></i> Learned Patterns</h4>
            <button type="button" class="btn btn-sm btn-ghost" onclick="clearLearnedPatterns()" title="Clear all learned patterns">
              <i class="fas fa-trash"></i> Clear
            </button>
          </div>
          <p class="settings-hint">Patterns learned from your categorizations. Patterns used 2+ times will be applied automatically.</p>
          <div class="patterns-list" id="learnedPatternsList">
            <!-- Populated dynamically -->
          </div>
        </div>

        <!-- Built-in Patterns (read-only) -->
        <div class="settings-section">
          <div class="settings-section-header">
            <h4><i class="fas fa-list"></i> Built-in Patterns</h4>
          </div>
          <p class="settings-hint">Default patterns that are always available. Custom and learned patterns take priority.</p>
          <div class="patterns-list builtin-patterns">
            <div class="pattern-item readonly">
              <span class="pattern-text">meeting, minutes, mom</span>
              <span class="pattern-category">Meeting Minutes</span>
            </div>
            <div class="pattern-item readonly">
              <span class="pattern-text">progress report, monthly report</span>
              <span class="pattern-category">Progress Reports</span>
            </div>
            <div class="pattern-item readonly">
              <span class="pattern-text">valuation, interim cert</span>
              <span class="pattern-category">Client Valuations</span>
            </div>
            <div class="pattern-item readonly">
              <span class="pattern-text">change, variation, vo</span>
              <span class="pattern-category">Change</span>
            </div>
            <div class="pattern-item readonly">
              <span class="pattern-text">drawing, dwg, plan</span>
              <span class="pattern-category">Drawings</span>
            </div>
            <div class="pattern-item readonly">
              <span class="pattern-text">spec, specification</span>
              <span class="pattern-category">Specifications</span>
            </div>
          </div>
        </div>
      </div>
      <div class="settings-modal-footer">
        <button type="button" class="btn btn-ghost" onclick="closeCategorySettings()">Close</button>
        <button type="button" class="btn btn-vericase" onclick="saveCategorySettings()">
          <i class="fas fa-save"></i> Save Settings
        </button>
      </div>
    </div>
  </div>

  <script>
    console.log("Evidence UI Version: 2.0.5 - CACHE BUSTED - " + Date.now());

    // ============================================
    // CONFIGURATION v1.0.1 - Cache bust
    // ============================================

    // Set AG Grid License Key (centralized)
    try {
      const agKey = window.VeriCaseConfig
        ? window.VeriCaseConfig.agGridLicenseKey
        : window.VERICASE_AG_GRID_LICENSE_KEY;
      if (agKey && window.agGrid && agGrid.LicenseManager) {
        agGrid.LicenseManager.setLicenseKey(agKey);
      }
    } catch (e) {
      console.warn("AG Grid license key init failed:", e);
    }

    const apiUrl = window.VeriCaseConfig
      ? window.VeriCaseConfig.apiUrl
      : window.location.origin;

    // Load AG Grid configuration from admin settings
    async function loadGridConfig() {
      try {
        const token = localStorage.getItem("token");
        if (!token) return {}; // Return empty config if not logged in

        const response = await fetch(`${apiUrl}/api/admin/settings`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) return {}; // Return empty config if fetch fails

        const settings = await response.json();
        const config = {};

        settings.forEach(s => {
          if (s.key.startsWith('ag_grid_')) {
            const settingKey = s.key.replace('ag_grid_', '');
            config[settingKey] = s.value;
          }
        });

        console.log('[Grid Config] Loaded admin settings:', config);
        return config;
      } catch (error) {
        console.error('[Grid Config] Error loading settings:', error);
        return {}; // Return empty config on error
      }
    }

    // Store admin config globally for grid initialization
    let adminGridConfig = {};

    let gridApi = null;
    let columnApi = null;
    let selectedEvidence = null;
    let currentPreviewData = null;
    let evidenceLane = "core";
    let includeLinkedNotes = false;
    let projectId = null;
    let caseId = null;
    let currentCategory = "documents";
    let loadAllDataPromise = null; // Prevent infinite loops
    let serverSideFilterModel = {};
    let gridStateApplied = false;
    let gridStateKey = "";
    let columnsPanelOpen = false;
    let collectionsCache = [];

    function updateEvidenceLaneButtons() {
      const buttons = document.querySelectorAll("#evidenceLaneTabs .lane-tab");
      buttons.forEach(btn => {
        if (btn.dataset.lane === evidenceLane) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    }

    function setEvidenceLane(lane) {
      evidenceLane = lane;
      updateEvidenceLaneButtons();
      updateEvidenceNotePlaceholder();
      loadEvidenceNotes();
    }

    function toggleLinkedNotes() {
      const checkbox = document.getElementById("includeLinkedNotes");
      includeLinkedNotes = checkbox ? checkbox.checked : false;
      loadEvidenceNotes();
    }

    function updateEvidenceNotePlaceholder() {
      const input = document.getElementById("evidenceCommentInput");
      if (!input) return;
      const placeholders = {
        core: "Record working position. (facts, evidence points, next steps)",
        counsel: "Record submissions. (legal test, pleadings framing, authorities)",
        expert: "Record expert analysis. (methodology, assumptions, conclusions)",
      };
      input.placeholder = placeholders[evidenceLane] || "Add a note for this evidence item...";
    }

    function renderEvidenceNote(comment, isReply = false) {
      const author = comment.created_by_name || "User";
      const time = comment.created_at ? formatTimeAgo(new Date(comment.created_at)) : "";
      const laneValue = (comment.lane || evidenceLane || "core").toLowerCase();
      const laneBadge = `<span class="lane-badge ${laneValue}">${laneValue}</span>`;
      const linkBadge = comment.item_claim_link_id ? `<span class="lane-badge">linked</span>` : "";
      const replies = comment.replies || [];

      return `
        <div class="collab-comment ${isReply ? "reply" : ""}">
          <div class="collab-comment-meta">${escapeHtml(author)}${time ? `  ${time}` : ""} ${laneBadge} ${linkBadge}</div>
          <div>${escapeHtml(comment.content)}</div>
          ${replies.length > 0 ? replies.map(r => renderEvidenceNote(r, true)).join("") : ""}
        </div>
      `;
    }

    async function loadEvidenceNotes() {
      const thread = document.getElementById("evidenceCommentThread");
      if (!thread) return;

      if (!selectedEvidence) {
        thread.innerHTML = `<div class="collab-empty">Select an item to view notes.</div>`;
        return;
      }

      thread.innerHTML = `<div class="collab-empty">Loading notes...</div>`;

      try {
        const response = await VeriCaseConfig.apiCall(
          `/api/claims/comments/evidence/${selectedEvidence.id}?lane=${encodeURIComponent(evidenceLane)}`
        );
        const items = Array.isArray(response) ? response : (response.items || []);
        const directComments = items.filter(c => !c.item_claim_link_id);
        const linkedComments = items.filter(c => c.item_claim_link_id);

        if (!includeLinkedNotes && directComments.length === 0) {
          thread.innerHTML = `<div class="collab-empty">No notes in this lane yet.</div>`;
          return;
        }

        let html = "";
        if (directComments.length > 0) {
          html += directComments.map(c => renderEvidenceNote(c)).join("");
        } else {
          html += `<div class="collab-empty">No direct notes in this lane yet.</div>`;
        }

        if (includeLinkedNotes) {
          if (linkedComments.length > 0) {
            html += `<div class="collab-section-title">Claim-linked notes</div>`;
            html += linkedComments.map(c => renderEvidenceNote(c)).join("");
          } else {
            html += `<div class="collab-empty">No claim-linked notes in this lane yet.</div>`;
          }
        }

        thread.innerHTML = html;
      } catch (error) {
        console.error("[Evidence] Failed to load notes:", error);
        thread.innerHTML = `<div class="collab-empty">Failed to load notes.</div>`;
      }
    }

    async function postEvidenceNote() {
      if (!selectedEvidence) {
        VericaseUI.Toast.warning("Select an evidence item first.");
        return;
      }

      const input = document.getElementById("evidenceCommentInput");
      if (!input) return;

      const content = input.value.trim();
      if (!content) {
        VericaseUI.Toast.warning("Enter a note before posting.");
        return;
      }

      try {
        await VeriCaseConfig.apiCall(`/api/claims/comments`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            content,
            item_type: "evidence",
            item_id: selectedEvidence.id,
            lane: evidenceLane,
          }),
        });

        input.value = "";
        VericaseUI.Toast.success("Note added");
        loadEvidenceNotes();
      } catch (error) {
        console.error("[Evidence] Failed to post note:", error);
        VericaseUI.Toast.error("Failed to add note");
      }
    }

    // Evidence type configuration
    const typeConfig = {
      contract: {
        label: "Contract",
        icon: "fa-file-contract",
        color: "#1e40af",
      },
      variation: {
        label: "Variation",
        icon: "fa-exchange-alt",
        color: "#92400e",
      },
      drawing: {
        label: "Drawing",
        icon: "fa-drafting-compass",
        color: "#3730a3",
      },
      specification: {
        label: "Specification",
        icon: "fa-clipboard-list",
        color: "#166534",
      },
      programme: {
        label: "Programme",
        icon: "fa-calendar-alt",
        color: "#0f766e",
      },
      invoice: {
        label: "Invoice",
        icon: "fa-file-invoice-dollar",
        color: "#166534",
      },
      payment_certificate: {
        label: "Payment Certificate",
        icon: "fa-certificate",
        color: "#0f766e",
      },
      meeting_minutes: {
        label: "Meeting Minutes",
        icon: "fa-id-badge",
        color: "#1e40af",
      },
      site_instruction: {
        label: "Site Instruction",
        icon: "fa-hard-hat",
        color: "#92400e",
      },
      rfi: { label: "RFI", icon: "fa-question-circle", color: "#6b21a8" },
      notice: {
        label: "Notice",
        icon: "fa-exclamation-triangle",
        color: "#991b1b",
      },
      letter: { label: "Letter", icon: "fa-envelope", color: "#475569" },
      email_attachment: {
        label: "Email Attachment",
        icon: "fa-paperclip",
        color: "#0369a1",
      },
      photo: { label: "Photo", icon: "fa-camera", color: "#6b21a8" },
      expert_report: {
        label: "Expert Report",
        icon: "fa-user-tie",
        color: "#1e40af",
      },
      pdf: { label: "PDF", icon: "fa-file-pdf", color: "#dc2626" },
      word_document: {
        label: "Word Doc",
        icon: "fa-file-word",
        color: "#2563eb",
      },
      spreadsheet: {
        label: "Spreadsheet",
        icon: "fa-file-excel",
        color: "#16a34a",
      },
      image: { label: "Image", icon: "fa-image", color: "#8b5cf6" },
      other: { label: "Other", icon: "fa-file", color: "#64748b" },
    };

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function getFileIcon(mimeType, evidenceType) {
      if (evidenceType && typeConfig[evidenceType]) {
        return typeConfig[evidenceType].icon;
      }
      if (mimeType) {
        if (mimeType.startsWith("image/")) return "fa-image";
        if (mimeType === "application/pdf") return "fa-file-pdf";
        if (mimeType.includes("word")) return "fa-file-word";
        if (mimeType.includes("excel") || mimeType.includes("spreadsheet"))
          return "fa-file-excel";
        if (
          mimeType.includes("powerpoint") ||
          mimeType.includes("presentation")
        )
          return "fa-file-powerpoint";
        if (mimeType.startsWith("text/")) return "fa-file-alt";
        if (mimeType.startsWith("audio/")) return "fa-file-audio";
        if (mimeType.startsWith("video/")) return "fa-file-video";
      }
      return "fa-file";
    }

    function getFileIconClass(mimeType) {
      if (!mimeType) return "";
      if (mimeType === "application/pdf") return "pdf";
      if (mimeType.includes("word")) return "word";
      if (mimeType.includes("excel") || mimeType.includes("spreadsheet"))
        return "excel";
      if (mimeType.startsWith("image/")) return "image";
      if (mimeType.includes("outlook") || mimeType === "message/rfc822")
        return "email";
      return "";
    }

    function formatFileSize(bytes) {
      if (!bytes) return "";
      const k = 1024;
      const sizes = ["B", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
    }

    function formatDate(dateStr) {
      if (!dateStr) return "-";
      try {
        const d = new Date(dateStr);
        return d.toLocaleDateString("en-GB", {
          day: "numeric",
          month: "short",
          year: "numeric",
        });
      } catch {
        return dateStr;
      }
    }

    function formatTimeAgo(date) {
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);

      if (minutes < 1) return "just now";
      if (minutes < 60) return `${minutes} min ago`;
      if (hours < 24) return `${hours} hour${hours > 1 ? "s" : ""} ago`;
      if (days < 7) return `${days} day${days > 1 ? "s" : ""} ago`;
      return date.toLocaleDateString();
    }

    function isImageFile(mimeType, filename) {
      if (mimeType?.startsWith("image/")) return true;
      const imageExts = [
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".webp",
        ".svg",
        ".bmp",
        ".tiff",
        ".tif",
      ];
      return imageExts.some((ext) => filename?.toLowerCase().endsWith(ext));
    }

    function getFileTypeInfo(mimeType, filename) {
      const ext = filename?.split(".").pop()?.toLowerCase() || "";
      if (mimeType === "application/pdf" || ext === "pdf")
        return { label: "PDF", class: "pdf" };
      if (mimeType?.includes("word") || ["doc", "docx"].includes(ext))
        return { label: "Word", class: "word" };
      if (
        mimeType?.includes("excel") ||
        mimeType?.includes("spreadsheet") ||
        ["xls", "xlsx", "csv"].includes(ext)
      )
        return { label: "Excel", class: "excel" };
      if (
        mimeType?.includes("powerpoint") ||
        mimeType?.includes("presentation") ||
        ["ppt", "pptx"].includes(ext)
      )
        return { label: "PPT", class: "ppt" };
      if (mimeType?.startsWith("text/") || ["txt", "log", "md"].includes(ext))
        return { label: "Text", class: "text" };
      if (mimeType?.startsWith("image/"))
        return { label: "Image", class: "image" };
      return { label: ext.toUpperCase() || "File", class: "" };
    }

    function escapeHtml(text) {
      if (!text) return "";
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // Infer category from evidence item based on filename patterns and metadata
    function inferCategory(item) {
      if (!item) return null;

      const haystack = `${item.filename || ""} ${item.title || ""}`.toLowerCase();
      const evidenceType = (item.evidence_type || "").toLowerCase();
      const mimeType = (item.mime_type || "").toLowerCase();

      // Load config to get custom and learned patterns
      const config = loadEvidenceConfig();

      // 1. First check custom patterns (highest priority - user defined)
      if (config.customPatterns && config.customPatterns.length > 0) {
        for (const {pattern, category} of config.customPatterns) {
          try {
            const regex = new RegExp(pattern, "i");
            if (regex.test(haystack)) {
              return category;
            }
          } catch (e) {
            console.warn(`Invalid custom pattern: ${pattern}`, e);
          }
        }
      }

      // 2. Check learned patterns (high count patterns first - learned from user)
      if (config.learnedPatterns && config.learnedPatterns.length > 0) {
        // Only use patterns that have been used at least twice
        const reliablePatterns = config.learnedPatterns.filter(p => (p.count || 1) >= 2);
        for (const {pattern, category} of reliablePatterns) {
          try {
            const regex = new RegExp(pattern, "i");
            if (regex.test(haystack)) {
              return category;
            }
          } catch (e) {
            console.warn(`Invalid learned pattern: ${pattern}`, e);
          }
        }
      }

      // 3. Built-in patterns (default fallback)
      const builtInPatterns = [
        { pattern: /meeting|minutes|mom/i, category: "Meeting Minutes" },
        { pattern: /progress.*report|monthly.*report|weekly.*report/i, category: "Progress Reports" },
        { pattern: /client.*valuation|valuation.*cert|interim.*cert/i, category: "Client Valuations" },
        { pattern: /client.*payment|payment.*cert/i, category: "Client Payment Certificates" },
        { pattern: /change|variation|vo|instruction/i, category: "Change" },
        { pattern: /subcontractor.*valuation|sub.*valuation|subc.*val/i, category: "Subcontractor Valuations" },
        { pattern: /subcontractor.*payment|sub.*payment|subc.*pay/i, category: "Subcontractor Payment Certificates" },
        { pattern: /site.*instruction|si\d|architect.*instruction|ai\d/i, category: "Site Instructions" },
        { pattern: /drawing|dwg|plan|elevation|section|detail/i, category: "Drawings" },
        { pattern: /spec|specification/i, category: "Specifications" },
      ];

      for (const {pattern, category} of builtInPatterns) {
        if (pattern.test(haystack)) {
          return category;
        }
      }

      // 4. Evidence type mapping (lowest priority)
      if (evidenceType === "meeting_minutes") return "Meeting Minutes";
      if (evidenceType === "drawing") return "Drawings";
      if (evidenceType === "specification") return "Specifications";
      if (evidenceType === "payment_certificate") return "Client Payment Certificates";
      if (evidenceType === "valuation") return "Client Valuations";

      return null;
    }

    // Auto-categorize all uncategorized evidence items
    async function runAutoCategorization() {
      const toggle = document.getElementById("autoCategorizeToggle");
      if (!toggle.checked) return;

      VericaseUI.Toast.info("Starting auto-categorization...");

      try {
        // Prefer server-side auto-categorization (fast + reliable)
        // Fallback to client-side logic if endpoint is unavailable.
        try {
          const query = new URLSearchParams();
          if (projectId) query.append("project_id", projectId);
          if (caseId) query.append("case_id", caseId);
          const qs = query.toString();

          const serverResp = await fetch(
            `${apiUrl}/api/evidence/items/auto-categorize${qs ? `?${qs}` : ""}`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                max_items: 500,
                create_collections: true,
                add_to_collections: true,
                dry_run: false,
              }),
            },
          );

          if (serverResp.ok) {
            const result = await serverResp.json();
            const categorized = result.categorized || 0;
            const createdCollections = result.created_collections || 0;
            const addedToCollections = result.added_to_collections || 0;

            if (categorized > 0) {
              let msg = `Auto-categorized ${categorized} items`;
              if (createdCollections > 0) msg += ` (created ${createdCollections} collections)`;
              if (addedToCollections > 0) msg += ` and filed ${addedToCollections} to collections`;
              VericaseUI.Toast.success(msg);
              refreshGridData();
              loadCollections();
            } else {
              VericaseUI.Toast.info("No items could be auto-categorized");
            }
            return; // Done.
          }

          // If endpoint doesn't exist yet, fall back to client-side.
          if (serverResp.status !== 404 && serverResp.status !== 405) {
            let detail = "";
            try {
              const err = await serverResp.json();
              detail = err?.detail || JSON.stringify(err);
            } catch (_) {
              // ignore
            }
            throw new Error(detail || `Auto-categorize failed (HTTP ${serverResp.status})`);
          }

          console.warn("[Auto-categorize] Server endpoint unavailable; using client-side fallback.");
        } catch (serverErr) {
          console.warn("[Auto-categorize] Server-side failed; using client-side fallback:", serverErr);
        }

        // Fetch uncategorized items (items with blank document_category)
        const query = new URLSearchParams();
        if (projectId) query.append("project_id", projectId);
        if (caseId) query.append("case_id", caseId);

        const response = await fetch(
          `${apiUrl}/api/evidence/items/server-side?${query.toString()}`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              startRow: 0,
              endRow: 500,
              filterModel: { document_category: { filterType: "text", filter: "", type: "blank" } }
            }),
          }
        );

        if (!response.ok) {
          throw new Error("Failed to fetch evidence items");
        }

        const data = await response.json();
        const items = data.rows || [];

        // Group items by suggested category
        const categoryGroups = {};
        for (const item of items) {
          if (item.document_category) continue;
          const suggestedCategory = inferCategory(item);
          if (suggestedCategory) {
            if (!categoryGroups[suggestedCategory]) {
              categoryGroups[suggestedCategory] = [];
            }
            categoryGroups[suggestedCategory].push(item);
          }
        }

        const categories = Object.keys(categoryGroups);
        if (categories.length === 0) {
          VericaseUI.Toast.info("No items could be auto-categorized");
          return;
        }

        // Refresh collections cache to get current state (scoped)
        const colParams = new URLSearchParams();
        colParams.append("include_system", "false");
        if (projectId) colParams.append("project_id", projectId);
        if (caseId) colParams.append("case_id", caseId);
        const collectionsResponse = await fetch(`${apiUrl}/api/evidence/collections?${colParams.toString()}`);
        let existingCollections = [];
        if (collectionsResponse.ok) {
          const colData = await collectionsResponse.json();
          existingCollections = Array.isArray(colData) ? colData : colData.collections || [];
        }
        const existingNames = new Set(existingCollections.map(c => (c.name || "").toLowerCase()));

        // Create collections for categories that don't exist
        const collectionIdMap = {};
        for (const c of existingCollections) {
          collectionIdMap[(c.name || "").toLowerCase()] = c.id;
        }

        for (const categoryName of categories) {
          const lowerName = categoryName.toLowerCase();
          if (!existingNames.has(lowerName)) {
            try {
              const createResponse = await fetch(`${apiUrl}/api/evidence/collections`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  name: categoryName,
                  description: `Auto-created collection for ${categoryName}`,
                  project_id: projectId || null,
                  case_id: caseId || null,
                  is_system: false,
                }),
              });
              if (createResponse.ok) {
                const newCollection = await createResponse.json();
                collectionIdMap[lowerName] = newCollection.id;
                console.log(`Created collection: ${categoryName}`);
              }
            } catch (e) {
              console.warn(`Failed to create collection ${categoryName}:`, e);
            }
          }
        }

        // Now categorize items and add them to collections
        let categorized = 0;
        let addedToCollection = 0;

        for (const [categoryName, itemsList] of Object.entries(categoryGroups)) {
          const collectionId = collectionIdMap[categoryName.toLowerCase()];

          for (const item of itemsList) {
            try {
              // Update the document_category field
              const updateResponse = await fetch(`${apiUrl}/api/evidence/items/${item.id}`, {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ document_category: categoryName }),
              });

              if (updateResponse.ok) {
                categorized++;

                // Also add to collection if we have a collection ID
                if (collectionId) {
                  try {
                    const addResponse = await fetch(
                      `${apiUrl}/api/evidence/collections/${collectionId}/items/${item.id}`,
                      { method: "POST" }
                    );
                    if (addResponse.ok) {
                      addedToCollection++;
                    }
                  } catch (e) {
                    // Item might already be in collection, ignore
                  }
                }
              }
            } catch (e) {
              console.warn(`Failed to categorize ${item.id}:`, e);
            }
          }
        }

        if (categorized > 0) {
          let msg = `Auto-categorized ${categorized} items`;
          if (addedToCollection > 0) {
            msg += ` and filed ${addedToCollection} to collections`;
          }
          VericaseUI.Toast.success(msg);
          refreshGridData();
          loadCollections();
        } else {
          VericaseUI.Toast.info("No items could be auto-categorized");
        }
      } catch (error) {
        console.error("Auto-categorization failed:", error);
        VericaseUI.Toast.error("Auto-categorization failed");
      }
    }

    function getFilingCollections() {
      const skip = new Set([
        "all evidence",
        "unassigned",
        "recent uploads",
        "starred",
      ]);
      return (collectionsCache || []).filter((c) => {
        const name = (c?.name || "").trim().toLowerCase();
        return name && !skip.has(name);
      });
    }

    function findCollectionByNames(names) {
      const lookup = new Set(names.map((n) => n.toLowerCase()));
      return getFilingCollections().find((c) =>
        lookup.has((c.name || "").toLowerCase()),
      );
    }

    function inferAutofileCollection(detail) {
      if (!detail) return null;
      const mimeType = detail.mime_type || "";
      const evidenceType = detail.evidence_type || "";
      const fileType = (detail.file_type || "").toLowerCase();

      if (mimeType.startsWith("image/")) {
        return (
          findCollectionByNames(["Photos", "Images", "Images & Media"]) || null
        );
      }
      if (evidenceType === "drawing") {
        return findCollectionByNames(["Drawings"]) || null;
      }
      if (evidenceType === "contract") {
        return findCollectionByNames(["Contracts"]) || null;
      }
      if (evidenceType === "invoice" || evidenceType === "payment_certificate") {
        return findCollectionByNames(["Invoices & Payments", "Invoices"]) || null;
      }
      if (evidenceType === "meeting_minutes") {
        return findCollectionByNames(["Meeting Minutes"]) || null;
      }
      if (
        evidenceType === "correspondence" ||
        evidenceType === "email_attachment" ||
        detail.source_type === "pst_extraction"
      ) {
        return findCollectionByNames(["Correspondence"]) || null;
      }
      if (fileType === "xls" || fileType === "xlsx") {
        return findCollectionByNames(["Programme"]) || null;
      }
      return null;
    }

    async function assignEvidenceToCollection(collectionId) {
      if (!selectedEvidence || !collectionId) return;
      try {
        const response = await fetch(
          `${apiUrl}/api/evidence/collections/${collectionId}/items/${selectedEvidence.id}`,
          { method: "POST" },
        );
        if (response.ok) {
          VericaseUI.Toast.success("Filed to collection");
          refreshGridData();
          loadCollections();
        } else {
          VericaseUI.Toast.error("Failed to file to collection");
        }
      } catch (e) {
        console.error("Collection assignment failed:", e);
        VericaseUI.Toast.error("Failed to file to collection");
      }
    }

    function setupCollectionActions() {
      const select = document.getElementById("collectionSelect");
      const assignBtn = document.getElementById("assignCollectionBtn");
      const autoBtn = document.getElementById("autoFileBtn");
      if (assignBtn && select) {
        assignBtn.addEventListener("click", () => {
          const collectionId = select.value;
          if (!collectionId) {
            VericaseUI.Toast.error("Select a collection first");
            return;
          }
          assignEvidenceToCollection(collectionId);
        });
      }
      if (autoBtn) {
        autoBtn.addEventListener("click", () => {
          const target = inferAutofileCollection(selectedEvidence);
          if (!target) {
            VericaseUI.Toast.error("No matching collection found");
            return;
          }
          assignEvidenceToCollection(target.id);
        });
      }
    }

    function getGridStateKey() {
      const ctxType = caseId ? "case" : "project";
      const ctxId = caseId || projectId || "default";
      return `vc_evidence_grid_state:${ctxType}:${ctxId}`;
    }

    function getEvidenceConfigKey() {
      const ctxType = caseId ? "case" : "project";
      const ctxId = caseId || projectId || "default";
      return `vc_evidence_config:${ctxType}:${ctxId}`;
    }

    function loadEvidenceConfig() {
      const key = getEvidenceConfigKey();
      const saved = localStorage.getItem(key);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          console.warn("Failed to parse evidence config:", e);
        }
      }
      return {
        autoCategorize: false,
        customPatterns: [], // User-defined patterns: [{pattern: "string", category: "Category Name"}]
        learnedPatterns: [], // Learned from user categorizations: [{pattern: "string", category: "Category Name", count: 1}]
        learningEnabled: true, // Whether to learn from user categorizations
      };
    }

    function saveEvidenceConfig(config) {
      const key = getEvidenceConfigKey();
      localStorage.setItem(key, JSON.stringify(config));
    }

    // Extract potential patterns from a filename for learning
    function extractPatternsFromFilename(filename) {
      if (!filename) return [];
      const patterns = [];
      const name = filename.toLowerCase().replace(/\.[^/.]+$/, ""); // Remove extension

      // Extract meaningful words (3+ chars, not common words)
      const stopWords = new Set(["the", "and", "for", "from", "with", "this", "that", "are", "was", "were", "been", "have", "has", "had", "will", "would", "could", "should", "may", "might", "must", "shall", "can", "need", "pdf", "doc", "docx", "xls", "xlsx"]);
      const words = name.split(/[^a-z0-9]+/).filter(w => w.length >= 3 && !stopWords.has(w));

      // Add individual significant words as patterns
      words.forEach(word => {
        if (word.length >= 4) {
          patterns.push(word);
        }
      });

      // Add two-word combinations for more specificity
      for (let i = 0; i < words.length - 1; i++) {
        patterns.push(`${words[i]}.*${words[i + 1]}`);
      }

      return patterns.slice(0, 5); // Limit to top 5 patterns
    }

    // Learn from user categorization
    function learnFromCategorization(filename, category) {
      if (!filename || !category) return;

      const config = loadEvidenceConfig();
      if (!config.learningEnabled) return;

      const patterns = extractPatternsFromFilename(filename);
      if (patterns.length === 0) return;

      // Initialize learned patterns if not exists
      if (!config.learnedPatterns) config.learnedPatterns = [];

      // Add or update learned patterns
      patterns.forEach(pattern => {
        const existing = config.learnedPatterns.find(
          p => p.pattern === pattern && p.category === category
        );
        if (existing) {
          existing.count = (existing.count || 1) + 1;
        } else {
          config.learnedPatterns.push({ pattern, category, count: 1 });
        }
      });

      // Keep only top patterns (limit to 100 to prevent storage bloat)
      config.learnedPatterns.sort((a, b) => (b.count || 1) - (a.count || 1));
      config.learnedPatterns = config.learnedPatterns.slice(0, 100);

      saveEvidenceConfig(config);
      console.log(`[Auto-categorize] Learned patterns from "${filename}"  ${category}`);
    }

    // ============================================
    // CATEGORY SETTINGS MODAL
    // ============================================

    const defaultCategories = [
      "Meeting Minutes",
      "Progress Reports",
      "Client Valuations",
      "Client Payment Certificates",
      "Change",
      "Subcontractor Valuations",
      "Subcontractor Payment Certificates",
      "Site Instructions",
      "Drawings",
      "Specifications"
    ];

    function openCategorySettings() {
      const modal = document.getElementById("categorySettingsModal");
      modal.classList.remove("hidden");
      populateSettingsModal();
    }

    function closeCategorySettings() {
      const modal = document.getElementById("categorySettingsModal");
      modal.classList.add("hidden");
    }

    function populateSettingsModal() {
      const config = loadEvidenceConfig();

      // Set learning toggle
      const learningToggle = document.getElementById("learningEnabledToggle");
      learningToggle.checked = config.learningEnabled !== false;

      // Render custom patterns
      renderCustomPatterns(config.customPatterns || []);

      // Render learned patterns
      renderLearnedPatterns(config.learnedPatterns || []);
    }

    function renderCustomPatterns(patterns) {
      const container = document.getElementById("customPatternsList");
      if (!patterns || patterns.length === 0) {
        container.innerHTML = '<div class="patterns-empty">No custom patterns defined. Click "Add" to create one.</div>';
        return;
      }

      container.innerHTML = patterns.map((p, idx) => `
        <div class="pattern-item">
          <span class="pattern-text">${escapeHtml(p.pattern)}</span>
          <span class="pattern-category">${escapeHtml(p.category)}</span>
          <button type="button" class="btn-delete" onclick="deleteCustomPattern(${idx})" title="Delete pattern">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `).join("");
    }

    function renderLearnedPatterns(patterns) {
      const container = document.getElementById("learnedPatternsList");
      if (!patterns || patterns.length === 0) {
        container.innerHTML = '<div class="patterns-empty">No patterns learned yet. Categorize some files to start learning.</div>';
        return;
      }

      // Show top 20 learned patterns
      const topPatterns = patterns.slice(0, 20);
      container.innerHTML = topPatterns.map((p, idx) => `
        <div class="pattern-item">
          <span class="pattern-text">${escapeHtml(p.pattern)}</span>
          <span class="pattern-category">${escapeHtml(p.category)}</span>
          <span class="pattern-count">${p.count || 1}</span>
          <button type="button" class="btn-delete" onclick="deleteLearnedPattern(${idx})" title="Delete pattern">
            <i class="fas fa-times"></i>
          </button>
        </div>
      `).join("");
    }

    function addCustomPattern() {
      const pattern = prompt("Enter pattern (regex syntax, e.g., 'report.*2024'):");
      if (!pattern || !pattern.trim()) return;

      // Validate regex
      try {
        new RegExp(pattern.trim());
      } catch (e) {
        VericaseUI.Toast.error("Invalid regex pattern: " + e.message);
        return;
      }

      // Select category
      const category = prompt(
        "Select category:\n" +
        defaultCategories.map((c, i) => `${i + 1}. ${c}`).join("\n") +
        "\n\nEnter number or custom category name:"
      );
      if (!category || !category.trim()) return;

      let finalCategory = category.trim();
      const num = parseInt(finalCategory);
      if (num >= 1 && num <= defaultCategories.length) {
        finalCategory = defaultCategories[num - 1];
      }

      const config = loadEvidenceConfig();
      if (!config.customPatterns) config.customPatterns = [];
      config.customPatterns.push({ pattern: pattern.trim(), category: finalCategory });
      saveEvidenceConfig(config);

      renderCustomPatterns(config.customPatterns);
      VericaseUI.Toast.success(`Pattern added: "${pattern.trim()}"  ${finalCategory}`);
    }

    function deleteCustomPattern(index) {
      const config = loadEvidenceConfig();
      if (config.customPatterns && config.customPatterns[index]) {
        config.customPatterns.splice(index, 1);
        saveEvidenceConfig(config);
        renderCustomPatterns(config.customPatterns);
        VericaseUI.Toast.success("Pattern deleted");
      }
    }

    function deleteLearnedPattern(index) {
      const config = loadEvidenceConfig();
      if (config.learnedPatterns && config.learnedPatterns[index]) {
        config.learnedPatterns.splice(index, 1);
        saveEvidenceConfig(config);
        renderLearnedPatterns(config.learnedPatterns);
        VericaseUI.Toast.success("Pattern deleted");
      }
    }

    function clearLearnedPatterns() {
      if (!confirm("Are you sure you want to clear all learned patterns? This cannot be undone.")) {
        return;
      }
      const config = loadEvidenceConfig();
      config.learnedPatterns = [];
      saveEvidenceConfig(config);
      renderLearnedPatterns([]);
      VericaseUI.Toast.success("All learned patterns cleared");
    }

    function saveCategorySettings() {
      const config = loadEvidenceConfig();
      const learningToggle = document.getElementById("learningEnabledToggle");
      config.learningEnabled = learningToggle.checked;
      saveEvidenceConfig(config);
      VericaseUI.Toast.success("Settings saved");
      closeCategorySettings();
    }

    function applySavedGridState() {
      if (!gridApi || !gridStateKey) return false;
      const raw = localStorage.getItem(gridStateKey);
      if (!raw) return false;
      try {
        const saved = JSON.parse(raw);
        if (!saved || !Array.isArray(saved.columnState)) return false;
        gridApi.applyColumnState({ state: saved.columnState, applyOrder: true });
        gridStateApplied = true;
        return true;
      } catch (e) {
        console.warn("Failed to apply saved grid state:", e);
        return false;
      }
    }

    function saveGridState() {
      if (!gridApi || !gridStateKey) return;
      const state = {
        version: 1,
        columnState: gridApi.getColumnState(),
      };
      localStorage.setItem(gridStateKey, JSON.stringify(state));
      if (window.VericaseUI && VericaseUI.Toast) {
        VericaseUI.Toast.success("Layout saved");
      }
    }

    function resetGridState() {
      if (!gridApi || !gridStateKey) return;
      localStorage.removeItem(gridStateKey);
      gridApi.resetColumnState();
      gridStateApplied = false;
      autoFitGrid(true);
      if (window.VericaseUI && VericaseUI.Toast) {
        VericaseUI.Toast.info("Layout reset");
      }
    }

    function autoFitGrid(force = false) {
      if (!gridApi) return;
      if (!force && gridStateApplied) return;
      requestAnimationFrame(() => {
        try {
          gridApi.sizeColumnsToFit();
        } catch (e) {
          console.warn("Auto-fit failed:", e);
        }
      });
    }

    function toggleColumnsPanel() {
      if (!gridApi) return;
      columnsPanelOpen = !columnsPanelOpen;
      if (columnsPanelOpen) {
        gridApi.setSideBarVisible(true);
        gridApi.openToolPanel("columns");
      } else {
        gridApi.closeToolPanel();
        gridApi.setSideBarVisible(false);
      }
    }

    // ============================================
    // GRID SETUP
    // ============================================

    async function initGrid() {
      // Load admin grid configuration
      adminGridConfig = await loadGridConfig();

      // Safe data accessor - prevents errors when data is missing
      const safeGet = (data, key, fallback = "") => {
        if (!data) return fallback;
        const val = data[key];
        if (val === null || val === undefined) return fallback;
        return val;
      };

      const gridOptions = {
        // AG Grid v35: Use legacy themes (CSS-based ag-theme-alpine) instead of new Theming API
        theme: "legacy",
        rowModelType: "serverSide",
        cacheBlockSize: 100,
        // v34.3+ Auto-size strategy: Fit columns to grid width on initial load
        autoSizeStrategy: {
          type: "fitGridWidth",
          defaultMinWidth: 60,
        },
        getRowId: (params) => {
          const id = params.data?.id;
          return id ? String(id) : undefined;
        },
        paginationPageSize: 100,
        columnDefs: [
          {
            field: "thumbnail",
            headerName: "",
            width: 60,
            sortable: false,
            filter: false,
            cellRenderer: (params) => {
              if (!params.data)
                return '<div class="grid-file-icon"><i class="fas fa-file"></i></div>';
              const mimeType = safeGet(params.data, "mime_type", "");
              const evidenceType = safeGet(params.data, "evidence_type", "");
              const downloadUrl = safeGet(params.data, "download_url", "");
              const icon = getFileIcon(mimeType, evidenceType);
              const iconClass = getFileIconClass(mimeType);
              if (mimeType.startsWith("image/") && downloadUrl) {
                return `<img src="${downloadUrl}" class="grid-thumbnail" alt="" loading="lazy">`;
              }
              return `<div class="grid-file-icon ${iconClass}"><i class="fas ${icon}"></i></div>`;
            },
          },
          {
            field: "filename",
            headerName: "Name",
            width: 280,
            minWidth: 180,
            maxWidth: 400,
            cellRenderer: (params) => {
              if (!params.data) return "-";
              const mimeType = safeGet(params.data, "mime_type", "");
              const filename = safeGet(params.data, "filename", "Unknown");
              const title = safeGet(params.data, "title", "");
              const fileSize = safeGet(params.data, "file_size", 0);
              const author = safeGet(params.data, "author", "");
              const pageCount = safeGet(params.data, "page_count", null);
              const docDate = safeGet(params.data, "document_date", null);
              const typeInfo = getFileTypeInfo(mimeType, filename);
              const metaParts = [
                typeInfo.label,
                formatFileSize(fileSize),
                pageCount ? `${pageCount} pages` : null,
                author ? author : null,
                docDate ? formatDate(docDate) : null,
              ].filter(Boolean);
              return `
                                <div class="file-info">
                                    <span class="file-name">${escapeHtml(title || filename)}</span>
                                    <span class="file-meta">${metaParts.join("  ")}</span>
                                </div>
                            `;
            },
          },
          {
            field: "document_date",
            headerName: "Date",
            width: 120,
            valueGetter: (params) =>
              params.data?.document_date ||
              params.data?.source_email_date ||
              null,
            valueFormatter: (params) => formatDate(params.value),
          },
          {
            field: "processing_status",
            headerName: "Status",
            width: 120,
            cellRenderer: (params) => {
              const rawStatus = String(params.value || "pending").toLowerCase();
              const row = params.data || {};
              const ocrCompleted = !!row.ocr_completed;
              const hasMetadata =
                !!row.page_count ||
                !!row.author ||
                (Array.isArray(row.extracted_parties) && row.extracted_parties.length > 0) ||
                (Array.isArray(row.auto_tags) && row.auto_tags.length > 0);

              // Derive a truthful UI status:
              // - "ready" means OCR/text extraction completed (ocr_completed=true)
              // - "processed" means metadata extracted only
              // - "pending" means not processed yet
              let status = rawStatus;

              // Email pseudo-rows can be "completed" - treat as ready.
              if (status === "completed") status = "ready";

              // If OCR is complete, always show ready.
              if (ocrCompleted) {
                status = "ready";
              } else if (status === "ready") {
                // Guard against incorrect backend status: ready without OCR completion.
                status = "processed";
              } else if (status === "pending" && hasMetadata) {
                // Some legacy rows may still show pending even after metadata extraction.
                status = "processed";
              }

              let displayLabel = status;
              if (status === "ready") displayLabel = "Complete";
              else if (status === "processed") displayLabel = "Processed";
              else if (status === "processing") displayLabel = "Processing";
              else if (status === "pending") displayLabel = "Pending";
              else if (status === "error") displayLabel = "Error";
              else displayLabel = status.charAt(0).toUpperCase() + status.slice(1);

              return `<span class="status-badge status-${status}">${displayLabel}</span>`;
            },
          },
          {
            field: "origin",
            headerName: "Origin",
            width: 160,
            valueGetter: (params) => {
              if (!params.data) return null;
              // Check if it's from an email attachment
              if (params.data.source_email_id) {
                return "Email Attachment";
              }
              // Check for uploader name
              if (params.data.uploader_name || params.data.uploader_display_name) {
                return params.data.uploader_name || params.data.uploader_display_name;
              }
              // Check for uploaded_by user ID (fallback)
              if (params.data.uploaded_by) {
                return "Manual Upload";
              }
              return "Manual Upload";
            },
            cellRenderer: (params) => {
              const origin = params.value;
              if (!origin) {
                return '<span style="color: var(--text-muted);"></span>';
              }
              const isEmail = origin === "Email Attachment";
              const icon = isEmail ? "fa-envelope" : "fa-user";
              const color = isEmail ? "var(--vericase-teal)" : "var(--text-secondary)";
              return `<span style="color: ${color}; font-weight: 500;"><i class="fas ${icon}" style="margin-right: 6px;"></i>${escapeHtml(origin)}</span>`;
            },
          },
          {
            field: "file_type",
            headerName: "Format",
            width: 100,
            cellRenderer: (params) => {
              const ext = params.value;
              if (!ext)
                return '<span style="color: var(--text-muted);"></span>';
              
              const mimeType = safeGet(params.data, "mime_type", "");
              const evidenceType = safeGet(params.data, "evidence_type", "");
              const icon = getFileIcon(mimeType, evidenceType);
              const iconClass = getFileIconClass(mimeType);
              
              return `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div class="grid-file-icon ${iconClass}" style="width: 24px; height: 24px; font-size: 0.75rem;">
                        <i class="fas ${icon}"></i>
                    </div>
                    <span style="text-transform: uppercase; font-weight: 500; font-size: 0.75rem;">${ext}</span>
                </div>
              `;
            },
          },
          {
            field: "extracted_parties",
            headerName: "Stakeholders",
            width: 160,
            enableRowGroup: true,  // Enable grouping by stakeholder
            cellRenderer: (params) => {
              const parties = params.value;
              if (!parties || !Array.isArray(parties) || parties.length === 0)
                return '<span style="color: var(--text-muted);"></span>';
              const display = parties.slice(0, 2).join(", ");
              const extra =
                parties.length > 2 ? ` +${parties.length - 2}` : "";
              return `<span style="color: var(--vericase-teal); font-size: 0.75rem;">${display}${extra}</span>`;
            },
          },
          // ============================================
          // INTELLIGENCE COLUMNS - AI Analysis Data
          // ============================================
          {
            field: "classification_confidence",
            headerName: "Confidence",
            headerTooltip: "Classification confidence score (0-100%)",
            width: 110,
            filter: "agNumberColumnFilter",
            cellRenderer: (params) => {
              const confidence = params.value;
              const aiAnalyzed = safeGet(params.data, "ai_analyzed", false);
              
              if (!aiAnalyzed || confidence === null || confidence === undefined) {
                return '<span class="ai-confidence-badge none" title="Not analyzed"><i class="fas fa-chart-bar"></i> </span>';
              }
              
              let level = "low";
              if (confidence >= 80) level = "high";
              else if (confidence >= 50) level = "medium";
              
              return `<span class="ai-confidence-badge ${level}" title="${confidence}% confidence">
                <i class="fas fa-brain"></i> ${confidence}%
              </span>`;
            },
          },
          {
            field: "auto_tags",
            headerName: "Auto Tags",
            headerTooltip: "Automatically generated tags from analysis",
            width: 180,
            filter: "agTextColumnFilter",
            cellRenderer: (params) => {
              const tags = params.value;
              if (!tags || !Array.isArray(tags) || tags.length === 0) {
                return '<span style="color: var(--text-muted);"></span>';
              }
              
              const displayTags = tags.slice(0, 3);
              const extra = tags.length > 3 ? ` <span style="color: var(--text-muted); font-size: 0.65rem;">+${tags.length - 3}</span>` : "";
              
              const tagHtml = displayTags.map(tag => {
                const icon = tag.includes("email") ? "fa-envelope" : 
                            tag.includes("contract") ? "fa-file-contract" :
                            tag.includes("invoice") ? "fa-file-invoice-dollar" :
                            tag.includes("meeting") ? "fa-users" :
                            tag.includes("drawing") ? "fa-drafting-compass" :
                            "fa-tag";
                return `<span class="auto-tag"><i class="fas ${icon}"></i>${escapeHtml(tag)}</span>`;
              }).join("");
              
              return `<div class="auto-tags-display">${tagHtml}${extra}</div>`;
            },
          },
          {
            field: "ai_analyzed",
            headerName: "",
            headerTooltip: "Processing status",
            width: 60,
            filter: "agSetColumnFilter",
            cellRenderer: (params) => {
              const analyzed = params.value;
              if (analyzed) {
                return '<span class="ai-analyzed-indicator analyzed" title="Analyzed"><i class="fas fa-check-circle"></i></span>';
              }
              return '<span class="ai-analyzed-indicator pending" title="Pending analysis"><i class="fas fa-clock"></i></span>';
            },
          },
          {
            field: "extracted_dates",
            headerName: "Key Dates",
            headerTooltip: "Dates extracted from document content",
            width: 120,
            hide: true,  // Hidden by default, can be shown via columns panel
            cellRenderer: (params) => {
              const dates = params.value;
              if (!dates || !Array.isArray(dates) || dates.length === 0) {
                return '<span style="color: var(--text-muted);"></span>';
              }
              const dateCount = dates.length;
              return `<span class="entity-tag date" title="${dateCount} dates extracted"><i class="fas fa-calendar"></i> ${dateCount} dates</span>`;
            },
          },
          {
            field: "extracted_amounts",
            headerName: "Amounts",
            headerTooltip: "Financial amounts extracted from document",
            width: 120,
            hide: true,  // Hidden by default
            cellRenderer: (params) => {
              const amounts = params.value;
              if (!amounts || !Array.isArray(amounts) || amounts.length === 0) {
                return '<span style="color: var(--text-muted);"></span>';
              }
              const amountCount = amounts.length;
              return `<span class="entity-tag money" title="${amountCount} amounts found"><i class="fas fa-pound-sign"></i> ${amountCount}</span>`;
            },
          },
          {
            field: "document_category",
            headerName: "Category",
            width: 150,
            editable: true,
            cellEditor: "agSelectCellEditor",
            cellEditorParams: {
              values: [
                "",
                "Meeting Minutes",
                "Progress Reports",
                "Client Valuations",
                "Client Payment Certificates",
                "Change",
                "Subcontractor Valuations",
                "Subcontractor Payment Certificates",
                "Site Instructions",
                "Drawings",
                "Specifications"
              ]
            },
            valueGetter: (params) => {
              // Try to get category from various possible fields
              return params.data?.document_category || params.data?.collection_name || "";
            },
            cellRenderer: (params) => {
              const category = params.value;
              if (!category)
                return '<span style="color: var(--text-muted);"></span>';
              return `<span style="color: var(--vericase-teal); font-weight: 500; font-size: 0.75rem;"><i class="fas fa-folder" style="margin-right: 4px;"></i>${escapeHtml(category)}</span>`;
            },
          },
          {
            field: "correspondence_count",
            headerName: "Links",
            width: 80,
            cellRenderer: (params) => {
              const count = params.value || 0;
              if (count > 0) {
                return `<span style="color: var(--vericase-teal);"><i class="fas fa-link"></i> ${count}</span>`;
              }
              return `<span style="color: var(--text-muted);"></span>`;
            },
          },
          {
            field: "source_email_subject",
            headerName: "Source Email",
            width: 200,
            wrapText: true,
            autoHeight: true,
            cellStyle: { 
              whiteSpace: 'normal',
              wordWrap: 'break-word',
              lineHeight: '1.4',
              padding: '8px'
            },
            cellRenderer: (params) => {
              const subject = params.value;
              const emailId = safeGet(params.data, "source_email_id", "");
              const senderName = safeGet(params.data, "source_email_sender", "");
              const preview = safeGet(params.data, "source_email_preview", "");
              const messageId = safeGet(params.data, "source_email_message_id", "");
              const evidenceId = safeGet(params.data, "id", "");
              
              if (!subject && !emailId) {
                return '<span style="color: var(--text-muted);">-</span>';
              }
              
              const displayText = subject || "Email";
              const senderInfo = senderName ? `<div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 4px;">From: ${escapeHtml(senderName)}</div>` : "";
              const previewInfo = preview ? `<div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 2px; line-height: 1.3;">${escapeHtml(preview.substring(0, 100))}${preview.length > 100 ? '...' : ''}</div>` : "";
              const ref = messageId || emailId;
              const refInfo = ref ? `\nRef: ${ref}` : "";
              
              if (emailId) {
                return `
                  <div style="display: flex; align-items: flex-start; gap: 8px; width: 100%;">
                    <div style="flex: 1; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                      <div style="color: var(--vericase-teal); font-weight: 500; word-wrap: break-word; overflow-wrap: break-word;">
                        <i class="fas fa-envelope-open-text" style="margin-right: 4px; font-size: 0.75rem;"></i>
                        <span style="word-wrap: break-word; overflow-wrap: break-word;">${escapeHtml(displayText)}</span>
                      </div>
                      ${senderInfo}
                      ${previewInfo}
                    </div>
                    <button 
                      class="btn-icon-small" 
                      onclick="event.stopPropagation(); openSourceEmail('${emailId}')" 
                      title="View source email${escapeHtml(refInfo)}"
                      style="flex-shrink: 0; padding: 4px 6px; border: none; background: transparent; color: var(--vericase-teal); cursor: pointer; border-radius: 4px; transition: background 0.2s;"
                      onmouseover="this.style.background='rgba(31, 111, 120, 0.1)'"
                      onmouseout="this.style.background='transparent'"
                    >
                      <i class="fas fa-external-link-alt" style="font-size: 0.75rem;"></i>
                    </button>
                  </div>
                `;
              }
              return `
                <div style="word-wrap: break-word; overflow-wrap: break-word;">
                  <span style="color: var(--text-secondary);">
                    <i class="fas fa-envelope" style="margin-right: 4px;"></i>
                    <span style="word-wrap: break-word; overflow-wrap: break-word;">${escapeHtml(displayText)}</span>
                  </span>
                  ${previewInfo}
                </div>
              `;
            },
          },
          {
            field: "is_starred",
            headerName: "",
            width: 50,
            sortable: false,
            filter: false,
            cellRenderer: (params) => {
              if (!params.data) return "";
              const starred = params.value;
              const id = safeGet(params.data, "id", "");
              return `<button class="star-btn ${starred ? "starred" : ""}" onclick="event.stopPropagation(); toggleStar('${id}')">
                                <i class="fas fa-star"></i>
                            </button>`;
            },
          },
        ],
        defaultColDef: {
          sortable: true,
          filter: true,
          resizable: true,
          floatingFilter: true,  // Enable inline filter inputs below headers
          wrapHeaderText: true,
          autoHeaderHeight: true,
          // Flexible cell rendering - handle any data type gracefully
          valueFormatter: (params) => {
            if (params.value === null || params.value === undefined)
              return "-";
            if (Array.isArray(params.value))
              return params.value.join(", ") || "-";
            if (typeof params.value === "object") {
              try {
                return JSON.stringify(params.value);
              } catch {
                return String(params.value);
              }
            }
            return String(params.value);
          },
          // Handle long text gracefully
          wrapText: true,
          autoHeight: true,
          cellStyle: { "white-space": "normal", "line-height": "1.35" },
        },
        // Suppress errors for missing row data
        // v35 Row Selection API: Object-based configuration (multi-select like correspondence)
        rowSelection: {
          mode: "multiRow",
          enableClickSelection: true,
          checkboxes: true,
          headerCheckbox: true,
        },
        // Enable Advanced Filter (Enterprise feature) - allows complex AND/OR queries
        enableAdvancedFilter: true,
        // Status bar with row count info
        statusBar: {
          statusPanels: [
            { statusPanel: 'agTotalRowCountComponent', align: 'left' },
            { statusPanel: 'agFilteredRowCountComponent', align: 'center' },
            { statusPanel: 'agSelectedRowCountComponent', align: 'right' }
          ]
        },
        animateRows: true,
        suppressRowTransform: true,
        sideBar: {
          toolPanels: [
            {
              id: "columns",
              labelDefault: "Columns",
              labelKey: "columns",
              iconKey: "columns",
              toolPanel: "agColumnsToolPanel",
              toolPanelParams: {
                // ENABLE Row Grouping - was suppressed!
                suppressRowGroups: false,
                suppressValues: false,
                suppressPivots: true,
                suppressPivotMode: true,
              },
            },
            {
              id: "filters",
              labelDefault: "Filters",
              labelKey: "filters",
              iconKey: "filter",
              toolPanel: "agFiltersToolPanel",
            },
          ],
          defaultToolPanel: "",
          hiddenByDefault: true,
        },
        // Enable Row Grouping
        rowGroupPanelShow: "always",
        groupDefaultExpanded: 1,
        // Enable aggregation on grouped data
        suppressAggFuncInHeader: false,
        // Enable Integrated Charts (AG Grid Enterprise)
        enableCharts: true,
        enableRangeSelection: true,
        chartThemeOverrides: {
          common: {
            title: {
              enabled: true,
              fontWeight: 'bold',
              fontSize: 14
            },
            legend: {
              position: 'bottom'
            }
          }
        },
        // Custom chart menu items
        getChartToolbarItems: () => {
          return [
            'chartSettings',
            'chartDownload', 
            'chartData',
            'chartFormat'
          ];
        },
        // Enable Master/Detail for correspondence/thread view
        masterDetail: true,
        isRowMaster: (dataItem) => {
          // Show detail expansion for rows with correspondence or from email threads
          return (dataItem && (
            (dataItem.correspondence_count && dataItem.correspondence_count > 0) ||
            dataItem.source_email_id ||
            (dataItem.extracted_parties && dataItem.extracted_parties.length > 0)
          ));
        },
        detailCellRendererParams: {
          // Render correspondence/thread details
          detailGridOptions: {
            columnDefs: [
              { field: 'filename', headerName: 'Related Document', flex: 2 },
              { field: 'document_category', headerName: 'Category', width: 150 },
              { field: 'document_date', headerName: 'Date', width: 120 },
              { 
                field: 'relationship', 
                headerName: 'Relationship',
                width: 150,
                cellRenderer: (p) => {
                  const rel = p.value || 'related';
                  const colors = {
                    'attachment': 'var(--vericase-teal)',
                    'reply': '#22c55e',
                    'forward': '#fbbf24',
                    'reference': '#8b5cf6'
                  };
                  return `<span style="color: ${colors[rel] || 'var(--text-secondary)'}">${rel}</span>`;
                }
              }
            ],
            defaultColDef: {
              flex: 1,
              resizable: true,
              sortable: true,
            },
          },
          getDetailRowData: async (params) => {
            // Fetch related documents/correspondence for this evidence item
            const evidenceId = params.data.id;
            try {
              const response = await fetch(`${apiUrl}/api/evidence/items/${evidenceId}/correspondence`);
              if (response.ok) {
                const data = await response.json();
                params.successCallback(data.items || []);
              } else {
                // If no correspondence endpoint, show extracted context
                const contextData = [];
                
                // Show email thread context if from email
                if (params.data.source_email_id) {
                  contextData.push({
                    filename: params.data.source_email_subject || 'Source Email',
                    document_category: 'Email',
                    document_date: params.data.source_email_date,
                    relationship: 'attachment'
                  });
                }
                
                // Show extracted parties as related context
                const parties = params.data.extracted_parties || [];
                parties.forEach(party => {
                  const name = typeof party === 'string' ? party : (party.name || party.company);
                  if (name) {
                    contextData.push({
                      filename: name,
                      document_category: 'Stakeholder',
                      relationship: 'reference'
                    });
                  }
                });
                
                params.successCallback(contextData);
              }
            } catch (e) {
              console.warn("[MasterDetail] Error fetching correspondence:", e);
              params.successCallback([]);
            }
          },
          template: `
            <div style="padding: 12px; background: rgba(31, 111, 120, 0.05); border-left: 3px solid var(--vericase-teal);">
              <div style="margin-bottom: 8px; font-weight: 600; color: var(--vericase-teal);">
                <i class="fas fa-link" style="margin-right: 6px;"></i>Related Documents & Context
              </div>
              <div ref="eDetailGrid" style="height: 150px;"></div>
            </div>
          `,
        },
        onGridReady: (params) => {
          gridApi = params.api;
          // columnApi is deprecated in v31, use gridApi for column operations
          columnApi = params.columnApi || null;
          gridStateKey = getGridStateKey();
          applySavedGridState();
          gridApi.setSideBarVisible(false);
        },
        onFirstDataRendered: () => {
          autoFitGrid();
        },
        // Handle selection changes for multi-select actions
        onSelectionChanged: () => {
          const selected = gridApi ? gridApi.getSelectedRows() : [];
          const countEl = document.getElementById("selectedCount");
          if (countEl) countEl.textContent = String(selected.length);
          // Enable/disable bulk action buttons based on selection
          const excludeBtn = document.getElementById("excludeSelectedBtn");
          if (excludeBtn) excludeBtn.disabled = selected.length === 0;
          const deleteBtn = document.getElementById("deleteSelectedBtn");
          if (deleteBtn) deleteBtn.disabled = selected.length === 0;
        },
        // Apply row height from admin settings (default 56 for evidence grid)
        rowHeight: adminGridConfig.default_row_height ? parseInt(adminGridConfig.default_row_height) : 56,
        headerHeight: 44,
        // Safe row click handler
        onRowClicked: (params) => {
          if (!params.data) return;
          const panel = document.getElementById("detailPanel");
          if (
            panel.classList.contains("open") &&
            selectedEvidence?.id === params.data.id
          ) {
            hideDetail();
            return;
          }
          showDetail(params.data);
        },
        // Handle grid errors gracefully
        onGridSizeChanged: (params) => {
          try {
            const gridEl = document.getElementById("evidenceGrid");
            if (!gridEl || gridEl.offsetWidth === 0) return;
            autoFitGrid();
          } catch (e) {
            console.warn("Grid size adjustment failed:", e);
          }
        },
        // Handle category changes when user edits the category cell
        onCellValueChanged: async (params) => {
          if (params.colDef.field === "document_category" && params.data?.id) {
            const evidenceId = params.data.id;
            const newCategory = params.newValue || "";
            const filename = params.data.filename || params.data.title || "";
            try {
              const response = await fetch(`${apiUrl}/api/evidence/items/${evidenceId}`, {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ document_category: newCategory }),
              });
              if (response.ok) {
                VericaseUI.Toast.success(`Category updated to "${newCategory || 'None'}"`);
                // Learn from this categorization for future auto-categorization
                if (newCategory && filename) {
                  learnFromCategorization(filename, newCategory);
                }
                // Refresh collections to update counts
                loadCollections();
              } else {
                const error = await response.json();
                VericaseUI.Toast.error(error.detail || "Failed to update category");
                // Revert the cell value on error
                params.node.setDataValue("document_category", params.oldValue);
              }
            } catch (error) {
              console.error("Error updating category:", error);
              VericaseUI.Toast.error("Failed to update category");
              params.node.setDataValue("document_category", params.oldValue);
            }
          }
        },
      };

      const gridDiv = document.getElementById("evidenceGrid");

      // Apply theme from admin settings
      const requestedTheme = String(adminGridConfig.theme || "quartz").toLowerCase();
      const supportedThemes = new Set(["quartz", "alpine"]);
      const theme = supportedThemes.has(requestedTheme) ? requestedTheme : "quartz";
      // Keep our custom theme class alongside the base theme.
      gridDiv.className = `ag-theme-${theme} ag-theme-vericase`;
      console.log("[Grid Config] Applied theme:", theme);

      // Use createGrid API (v31+) instead of deprecated new Grid()
      gridApi = agGrid.createGrid(gridDiv, gridOptions);
      gridApi.setGridOption("serverSideDatasource", createServerSideDatasource());
      gridApi.showLoadingOverlay(); // Show overlay immediately so user sees a loading state

      console.log("[Evidence] Grid initialized with admin config:", adminGridConfig);
    }

    // ============================================
    // DATA LOADING (with prefetch support)
    // ============================================

    // Check for prefetched data from master dashboard
    function getPrefetchedData() {
      try {
        const cached = sessionStorage.getItem("vericase_evidence_prefetch");
        if (cached) {
          const data = JSON.parse(cached);
          // Only use if cached within last 5 minutes
          const MAX_AGE = 5 * 60 * 1000;
          if (Date.now() - data.timestamp < MAX_AGE) {
            console.log("[Evidence] Using prefetched data from dashboard");
            return data;
          }
          // Clear stale cache
          sessionStorage.removeItem("vericase_evidence_prefetch");
        }
      } catch (e) {
        console.warn("[Evidence] Prefetch cache read failed:", e);
      }
      return null;
    }

    // ============================================
    // AI INTELLIGENCE PANEL FUNCTIONS
    // ============================================
    
    let intelligencePanelOpen = false;
    let aiChatHistory = [];
    
    function openIntelligencePanel() {
      const panel = document.getElementById("intelligencePanel");
      if (panel) {
        panel.classList.add("open");
        intelligencePanelOpen = true;
        updateIntelligenceStats();
      }
    }
    
    function closeIntelligencePanel() {
      const panel = document.getElementById("intelligencePanel");
      if (panel) {
        panel.classList.remove("open");
        intelligencePanelOpen = false;
      }
    }
    
    function toggleIntelligencePanel() {
      if (intelligencePanelOpen) {
        closeIntelligencePanel();
      } else {
        openIntelligencePanel();
      }
    }
    
    // Update the intelligence stats from grid data
    async function updateIntelligenceStats() {
      try {
        // Fetch intelligence summary from backend
        const response = await fetch(`${apiUrl}/api/enhanced/services/status`);
        if (response.ok) {
          const data = await response.json();
          console.log("[AI Intelligence] Services status:", data);
        }
        
        // Calculate stats from currently loaded grid data
        let aiAnalyzedCount = 0;
        let totalConfidence = 0;
        let confidenceCount = 0;
        let entitiesCount = 0;
        
        if (gridApi) {
          gridApi.forEachNode((node) => {
            if (node.data) {
              if (node.data.ai_analyzed) aiAnalyzedCount++;
              if (node.data.classification_confidence) {
                totalConfidence += node.data.classification_confidence;
                confidenceCount++;
              }
              if (node.data.extracted_parties?.length) {
                entitiesCount += node.data.extracted_parties.length;
              }
            }
          });
        }
        
        document.getElementById("aiAnalyzedCount").textContent = aiAnalyzedCount.toString();
        document.getElementById("entitiesExtracted").textContent = entitiesCount.toString();
        document.getElementById("avgConfidence").textContent = confidenceCount > 0 
          ? Math.round(totalConfidence / confidenceCount) + "%" 
          : "";
        
      } catch (e) {
        console.warn("[AI Intelligence] Stats update failed:", e);
      }
    }
    
    // Execute a pre-defined AI query
    function executeAIQuery(query) {
      const input = document.getElementById("aiChatInput");
      if (input) {
        input.value = query;
        sendAIQuery();
      }
    }
    
    // Send a natural language query to AI
    async function sendAIQuery() {
      const input = document.getElementById("aiChatInput");
      const messagesContainer = document.getElementById("aiChatMessages");
      const sendBtn = document.getElementById("aiSendBtn");
      
      if (!input || !messagesContainer) return;
      
      const query = input.value.trim();
      if (!query) return;
      
      // Disable input while processing
      input.disabled = true;
      sendBtn.disabled = true;
      
      // Add user message
      const userMsgEl = document.createElement("div");
      userMsgEl.className = "ai-chat-message user";
      userMsgEl.textContent = query;
      messagesContainer.appendChild(userMsgEl);
      
      // Clear input
      input.value = "";
      
      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      try {
        // Process natural language query
        const result = await processNaturalLanguageQuery(query);
        
        // Add assistant response
        const assistantMsgEl = document.createElement("div");
        assistantMsgEl.className = "ai-chat-message assistant";
        assistantMsgEl.innerHTML = result.response;
        messagesContainer.appendChild(assistantMsgEl);
        
        // Show semantic search results if any
        if (result.searchResults?.length > 0) {
          showSemanticSearchResults(result.searchResults);
        }
        
      } catch (e) {
        console.error("[AI Query] Failed:", e);
        const errorMsgEl = document.createElement("div");
        errorMsgEl.className = "ai-chat-message system";
        errorMsgEl.textContent = "Sorry, I encountered an error. Please try again.";
        messagesContainer.appendChild(errorMsgEl);
      }
      
      // Re-enable input
      input.disabled = false;
      sendBtn.disabled = false;
      input.focus();
      
      // Scroll to bottom
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    // Process natural language query - local pattern matching + backend semantic search
    async function processNaturalLanguageQuery(query) {
      const lowerQuery = query.toLowerCase();
      let response = "";
      let searchResults = [];
      let gridAction = null;
      
      // Pattern matching for grid manipulation commands
      if (lowerQuery.includes("group by") || lowerQuery.includes("group ")) {
        if (lowerQuery.includes("type") || lowerQuery.includes("format")) {
          gridAction = { type: "groupBy", field: "file_type" };
          response = "<strong>Grouped by document type.</strong><br>Drag columns to the group row above the grid to add more groupings.";
        } else if (lowerQuery.includes("category")) {
          gridAction = { type: "groupBy", field: "document_category" };
          response = "<strong>Grouped by category.</strong><br>You can expand each group to see its documents.";
        } else if (lowerQuery.includes("stakeholder") || lowerQuery.includes("party") || lowerQuery.includes("parties")) {
          gridAction = { type: "groupBy", field: "extracted_parties" };
          response = "<strong>Grouped by stakeholder.</strong><br>Documents are now organized by who they're from/about.";
        } else if (lowerQuery.includes("origin")) {
          gridAction = { type: "groupBy", field: "origin" };
          response = "<strong>Grouped by origin.</strong><br>See email attachments vs manual uploads.";
        } else if (lowerQuery.includes("status")) {
          gridAction = { type: "groupBy", field: "processing_status" };
          response = "<strong>Grouped by processing status.</strong>";
        }
      } else if (lowerQuery.includes("clear group") || lowerQuery.includes("ungroup") || lowerQuery.includes("remove group")) {
        gridAction = { type: "clearGroups" };
        response = "<strong>Grouping cleared.</strong><br>Grid is now showing a flat list.";
      } else if (lowerQuery.includes("show") && (lowerQuery.includes("column") || lowerQuery.includes("sidebar") || lowerQuery.includes("panel"))) {
        if (gridApi) gridApi.setSideBarVisible(true);
        response = "<strong>Opened sidebar.</strong><br>You can drag columns to group, or use filters.";
      } else if (lowerQuery.includes("high confidence") || lowerQuery.includes("high-confidence")) {
        gridAction = { type: "filter", field: "classification_confidence", operator: "greaterThan", value: 80 };
        response = "<strong>Filtered to high-confidence items (>80%).</strong><br>These are documents the AI is most certain about.";
      } else if (lowerQuery.includes("pdf") || lowerQuery.includes("pdfs")) {
        gridAction = { type: "filter", field: "file_type", value: "pdf" };
        response = "<strong>Filtered to PDF documents.</strong>";
      } else if (lowerQuery.includes("email") || lowerQuery.includes("emails")) {
        gridAction = { type: "filter", field: "origin", value: "Email Attachment" };
        response = "<strong>Filtered to email attachments.</strong>";
      } else if (lowerQuery.includes("clear filter") || lowerQuery.includes("show all") || lowerQuery.includes("reset")) {
        if (gridApi) gridApi.setFilterModel(null);
        response = "<strong>Filters cleared.</strong><br>Showing all documents.";
      } else {
        // Semantic search for content-based queries
        try {
          const caseId = new URLSearchParams(window.location.search).get("case") || "";
          const searchResponse = await fetch(`${apiUrl}/api/enhanced/search/semantic?query=${encodeURIComponent(query)}&case_id=${caseId}&limit=5`, {
            method: "POST"
          });
          
          if (searchResponse.ok) {
            const data = await searchResponse.json();
            searchResults = data.results || [];
            
            if (searchResults.length > 0) {
              response = `<strong>Found ${searchResults.length} relevant documents.</strong><br>Click on any result below to view it.`;
            } else {
              response = "<strong>No matching documents found.</strong><br>Try rephrasing your query or use different keywords.";
            }
          } else {
            response = `I understand you're looking for: <em>"${query}"</em><br><br>Try commands like:<br> "Group by category"<br> "Show PDFs"<br> "Filter to high confidence items"`;
          }
        } catch (e) {
          console.warn("[Semantic Search] Backend not available:", e);
          response = `<strong>Query understood:</strong> "${query}"<br><br>The semantic search backend is not available. Try grid commands like:<br> "Group by type"<br> "Show emails"<br> "Clear filters"`;
        }
      }
      
      // Execute grid action if any
      if (gridAction && gridApi) {
        executeGridAction(gridAction);
      }
      
      return { response, searchResults };
    }
    
    // Execute a grid manipulation action
    function executeGridAction(action) {
      if (!gridApi) return;
      
      switch (action.type) {
        case "groupBy":
          const colDef = gridApi.getColumnDef(action.field);
          if (colDef) {
            gridApi.applyColumnState({
              state: [{ colId: action.field, rowGroup: true }],
              defaultState: { rowGroup: false }
            });
          }
          break;
          
        case "clearGroups":
          const columnState = gridApi.getColumnState();
          const newState = columnState.map(col => ({ ...col, rowGroup: false }));
          gridApi.applyColumnState({ state: newState });
          break;
          
        case "filter":
          const filterModel = {};
          if (action.operator === "greaterThan") {
            filterModel[action.field] = {
              filterType: "number",
              type: "greaterThan",
              filter: action.value
            };
          } else {
            filterModel[action.field] = {
              filterType: "text",
              type: "contains",
              filter: action.value
            };
          }
          gridApi.setFilterModel(filterModel);
          break;
      }
    }
    
    // Show semantic search results in the panel
    function showSemanticSearchResults(results) {
      const container = document.getElementById("semanticSearchResults");
      if (!container) return;
      
      if (results.length === 0) {
        container.style.display = "none";
        return;
      }
      
      container.style.display = "block";
      container.innerHTML = results.map(r => `
        <div class="semantic-result-item" onclick="navigateToEvidence('${r.evidence_id || r.document_id || ""}')">
          <div class="semantic-result-title">${escapeHtml(r.filename || r.title || "Document")}</div>
          <div class="semantic-result-snippet">${escapeHtml((r.snippet || r.text_excerpt || "").substring(0, 150))}...</div>
          ${r.score ? `<div class="semantic-result-score"><i class="fas fa-chart-line"></i> Relevance: ${Math.round(r.score * 100)}%</div>` : ""}
        </div>
      `).join("");
    }
    
    // Navigate to a specific evidence item
    function navigateToEvidence(evidenceId) {
      if (!evidenceId || !gridApi) return;
      
      // Find the row with this ID
      gridApi.forEachNode((node) => {
        if (node.data?.id === evidenceId) {
          gridApi.ensureNodeVisible(node, "middle");
          node.setSelected(true);
          showDetail(node.data);
        }
      });
    }
    
    // Setup AI Intelligence button handler
    function setupAIIntelligenceButton() {
      const aiBtn = document.getElementById("aiIntelligenceBtn");
      if (aiBtn) {
        aiBtn.addEventListener("click", toggleIntelligencePanel);
      }
    }
    
    // Setup Charts dropdown
    function setupChartsDropdown() {
      const chartsBtn = document.getElementById("chartsDropdownBtn");
      const chartsMenu = document.getElementById("chartsDropdownMenu");
      
      if (chartsBtn && chartsMenu) {
        chartsBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          const isVisible = chartsMenu.style.display === "block";
          chartsMenu.style.display = isVisible ? "none" : "block";
        });
        
        // Close dropdown when clicking outside
        document.addEventListener("click", (e) => {
          if (!chartsBtn.contains(e.target) && !chartsMenu.contains(e.target)) {
            chartsMenu.style.display = "none";
          }
        });
        
        // Add hover effects to dropdown items
        const items = chartsMenu.querySelectorAll(".dropdown-item");
        items.forEach(item => {
          item.addEventListener("mouseenter", () => {
            item.style.background = "rgba(31, 111, 120, 0.1)";
          });
          item.addEventListener("mouseleave", () => {
            item.style.background = "transparent";
          });
        });
      }
    }
    
    // Create chart from grid data using AG Grid Enterprise Integrated Charts
    async function createChart(chartType) {
      // Close dropdown
      const chartsMenu = document.getElementById("chartsDropdownMenu");
      if (chartsMenu) chartsMenu.style.display = "none";
      
      if (!gridApi) {
        console.warn("[Charts] Grid API not available");
        return;
      }
      
      // Get all row data from the grid
      const rowData = [];
      gridApi.forEachNode(node => {
        if (node.data) rowData.push(node.data);
      });
      
      if (rowData.length === 0) {
        alert("No data available for charting. Please load some documents first.");
        return;
      }
      
      console.log(`[Charts] Creating ${chartType} chart with ${rowData.length} rows`);
      
      try {
        switch (chartType) {
          case 'category-pie':
            createCategoryPieChart(rowData);
            break;
          case 'type-bar':
            createFileTypeBarChart(rowData);
            break;
          case 'timeline':
            createTimelineChart(rowData);
            break;
          case 'confidence-histogram':
            createConfidenceHistogram(rowData);
            break;
          case 'stakeholder-network':
            createStakeholderChart(rowData);
            break;
          default:
            console.warn(`[Charts] Unknown chart type: ${chartType}`);
        }
      } catch (error) {
        console.error("[Charts] Error creating chart:", error);
        alert(`Error creating chart: ${error.message}`);
      }
    }
    
    // Category Distribution Pie Chart
    function createCategoryPieChart(rowData) {
      const categoryCounts = {};
      rowData.forEach(row => {
        const category = row.document_category || row.evidence_type || "Uncategorized";
        categoryCounts[category] = (categoryCounts[category] || 0) + 1;
      });
      
      const chartData = Object.entries(categoryCounts).map(([category, count]) => ({
        category: category,
        count: count
      }));
      
      // Use AG Grid's createRangeChart API
      gridApi.createRangeChart({
        chartType: 'pie',
        cellRange: {
          columns: ['document_category'],
        },
        aggFunc: 'count',
        chartThemeOverrides: {
          pie: {
            title: {
              enabled: true,
              text: 'Document Category Distribution'
            }
          }
        }
      });
    }
    
    // File Type Bar Chart
    function createFileTypeBarChart(rowData) {
      gridApi.createRangeChart({
        chartType: 'groupedBar',
        cellRange: {
          columns: ['file_type'],
        },
        aggFunc: 'count',
        chartThemeOverrides: {
          bar: {
            title: {
              enabled: true,
              text: 'Document Types'
            }
          }
        }
      });
    }
    
    // Document Timeline Chart
    function createTimelineChart(rowData) {
      // Group by month
      gridApi.createRangeChart({
        chartType: 'line',
        cellRange: {
          columns: ['document_date'],
        },
        aggFunc: 'count',
        chartThemeOverrides: {
          line: {
            title: {
              enabled: true,
              text: 'Documents Over Time'
            }
          }
        }
      });
    }
    
    // AI Confidence Histogram
    function createConfidenceHistogram(rowData) {
      // For confidence scores, create a custom popup chart
      const confidenceCounts = { 
        "High (80-100%)": 0, 
        "Medium (50-79%)": 0, 
        "Low (0-49%)": 0,
        "Not Analyzed": 0 
      };
      
      rowData.forEach(row => {
        const conf = row.classification_confidence;
        if (conf === null || conf === undefined) {
          confidenceCounts["Not Analyzed"]++;
        } else if (conf >= 80) {
          confidenceCounts["High (80-100%)"]++;
        } else if (conf >= 50) {
          confidenceCounts["Medium (50-79%)"]++;
        } else {
          confidenceCounts["Low (0-49%)"]++;
        }
      });
      
      // Create a popup with chart visualization
      showChartPopup("AI Classification Confidence", `
        <div style="padding: 20px;">
          <div style="display: flex; flex-direction: column; gap: 12px;">
            ${Object.entries(confidenceCounts).map(([label, count]) => {
              const pct = ((count / rowData.length) * 100).toFixed(1);
              const color = label.includes("High") ? "#22c55e" 
                         : label.includes("Medium") ? "#fbbf24" 
                         : label.includes("Low") ? "#ef4444" 
                         : "#6b7280";
              return `
                <div style="display: flex; align-items: center; gap: 12px;">
                  <span style="width: 140px; font-weight: 500;">${label}</span>
                  <div style="flex: 1; background: rgba(255,255,255,0.1); height: 24px; border-radius: 4px; overflow: hidden;">
                    <div style="width: ${pct}%; height: 100%; background: ${color}; display: flex; align-items: center; padding-left: 8px;">
                      <span style="color: white; font-size: 0.8rem; font-weight: 600;">${count} (${pct}%)</span>
                    </div>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
          <div style="margin-top: 20px; padding-top: 12px; border-top: 1px solid var(--border-color); color: var(--text-muted); font-size: 0.85rem;">
            Total documents analyzed: ${rowData.length}
          </div>
        </div>
      `);
    }
    
    // Stakeholder Network Chart
    function createStakeholderChart(rowData) {
      const stakeholderCounts = {};
      
      rowData.forEach(row => {
        const parties = row.extracted_parties || [];
        parties.forEach(party => {
          const name = typeof party === 'string' ? party : (party.name || party.company || JSON.stringify(party));
          if (name) {
            stakeholderCounts[name] = (stakeholderCounts[name] || 0) + 1;
          }
        });
      });
      
      const sortedStakeholders = Object.entries(stakeholderCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15); // Top 15 stakeholders
      
      showChartPopup("Top Stakeholders", `
        <div style="padding: 20px;">
          <div style="display: flex; flex-direction: column; gap: 8px;">
            ${sortedStakeholders.length > 0 ? sortedStakeholders.map(([name, count], idx) => {
              const maxCount = sortedStakeholders[0][1];
              const pct = ((count / maxCount) * 100).toFixed(0);
              return `
                <div style="display: flex; align-items: center; gap: 12px;">
                  <span style="width: 24px; color: var(--text-muted); text-align: right;">${idx + 1}.</span>
                  <span style="width: 200px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${name}">${name}</span>
                  <div style="flex: 1; background: rgba(255,255,255,0.1); height: 20px; border-radius: 4px; overflow: hidden;">
                    <div style="width: ${pct}%; height: 100%; background: linear-gradient(90deg, var(--vericase-teal), #8b5cf6);"></div>
                  </div>
                  <span style="width: 50px; text-align: right; color: var(--text-secondary);">${count}</span>
                </div>
              `;
            }).join('') : '<p style="color: var(--text-muted);">No stakeholders extracted yet. Run AI analysis on documents first.</p>'}
          </div>
        </div>
      `);
    }
    
    // Open Case Insights panel
    async function openCaseInsights() {
      const caseId = currentCaseId || new URLSearchParams(window.location.search).get('case_id');
      const projectId = currentProjectId || new URLSearchParams(window.location.search).get('project_id');
      
      if (!caseId && !projectId) {
        showChartPopup("Case Insights", `
          <div style="padding: 20px; text-align: center; color: var(--text-muted);">
            <i class="fas fa-info-circle" style="font-size: 2rem; margin-bottom: 12px;"></i>
            <p>Please select a case or project to generate insights.</p>
          </div>
        `);
        return;
      }
      
      // Show loading state
      showChartPopup("Case Insights", `
        <div style="padding: 40px; text-align: center;">
          <div class="ai-pulse-large"></div>
          <p style="margin-top: 16px; color: var(--text-secondary);">Generating AI insights...</p>
          <p style="color: var(--text-muted); font-size: 0.85rem;">Analyzing documents and extracting key information</p>
        </div>
      `);
      
      try {
        const endpoint = caseId 
          ? `${apiUrl}/api/enhanced/case/${caseId}/insights`
          : `${apiUrl}/api/enhanced/project/${projectId}/insights`;
          
        const response = await fetch(endpoint);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch insights: ${response.status}`);
        }
        
        const insights = await response.json();
        
        // Render insights
        renderCaseInsights(insights);
        
      } catch (error) {
        console.error("[CaseInsights] Error:", error);
        
        // Show fallback with local analysis
        const localInsights = generateLocalInsights();
        renderCaseInsights(localInsights);
      }
    }
    
    // Generate local insights from grid data when API unavailable
    function generateLocalInsights() {
      const rowData = [];
      if (gridApi) {
        gridApi.forEachNode(node => {
          if (node.data) rowData.push(node.data);
        });
      }
      
      const totalDocs = rowData.length;
      const categories = {};
      const aiAnalyzed = rowData.filter(r => r.ai_analyzed).length;
      const highConfidence = rowData.filter(r => r.classification_confidence >= 80).length;
      const stakeholders = new Set();
      const dateRange = { earliest: null, latest: null };
      
      rowData.forEach(row => {
        // Categories
        const cat = row.document_category || 'Uncategorized';
        categories[cat] = (categories[cat] || 0) + 1;
        
        // Stakeholders
        (row.extracted_parties || []).forEach(p => {
          const name = typeof p === 'string' ? p : (p.name || p.company);
          if (name) stakeholders.add(name);
        });
        
        // Date range
        const docDate = row.document_date;
        if (docDate) {
          const d = new Date(docDate);
          if (!dateRange.earliest || d < dateRange.earliest) dateRange.earliest = d;
          if (!dateRange.latest || d > dateRange.latest) dateRange.latest = d;
        }
      });
      
      const topCategories = Object.entries(categories)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      return {
        summary: `Repository contains ${totalDocs} documents spanning ${topCategories.length} categories. ${aiAnalyzed} documents have been analyzed with AI classification, with ${highConfidence} showing high confidence scores.`,
        key_findings: [
          `${stakeholders.size} unique stakeholders identified across the evidence`,
          topCategories.length > 0 ? `Top document category: ${topCategories[0][0]} (${topCategories[0][1]} documents)` : null,
          dateRange.earliest && dateRange.latest ? `Documents date from ${dateRange.earliest.toLocaleDateString()} to ${dateRange.latest.toLocaleDateString()}` : null,
          `${Math.round((aiAnalyzed / totalDocs) * 100)}% of documents have AI analysis complete`,
        ].filter(Boolean),
        document_stats: {
          total: totalDocs,
          ai_analyzed: aiAnalyzed,
          high_confidence: highConfidence,
          categories: topCategories
        },
        stakeholders: Array.from(stakeholders).slice(0, 10),
        recommendations: [
          aiAnalyzed < totalDocs * 0.8 ? "Consider running AI analysis on remaining documents to improve classification" : null,
          stakeholders.size > 20 ? "Large number of stakeholders detected - consider creating stakeholder groups" : null,
          "Review high-confidence classifications for accuracy before case submission",
        ].filter(Boolean),
        source: 'local_analysis'
      };
    }
    
    // Render case insights in popup
    function renderCaseInsights(insights) {
      const isLocal = insights.source === 'local_analysis';
      
      const content = `
        <div style="padding: 20px; max-height: 60vh; overflow-y: auto;">
          ${isLocal ? `
            <div style="background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
              <i class="fas fa-info-circle" style="color: #fbbf24; margin-right: 6px;"></i>
              <span style="color: #fbbf24; font-size: 0.9rem;">Showing local analysis. Connect to AWS Bedrock for AI-enhanced insights.</span>
            </div>
          ` : ''}
          
          <!-- Summary -->
          <div style="margin-bottom: 20px;">
            <h4 style="color: var(--vericase-teal); margin-bottom: 8px;"><i class="fas fa-file-alt" style="margin-right: 8px;"></i>Summary</h4>
            <p style="color: var(--text-secondary); line-height: 1.6;">${insights.summary || 'No summary available'}</p>
          </div>
          
          <!-- Key Findings -->
          ${insights.key_findings && insights.key_findings.length > 0 ? `
            <div style="margin-bottom: 20px;">
              <h4 style="color: var(--vericase-teal); margin-bottom: 8px;"><i class="fas fa-lightbulb" style="margin-right: 8px;"></i>Key Findings</h4>
              <ul style="margin: 0; padding-left: 20px; color: var(--text-secondary);">
                ${insights.key_findings.map(f => `<li style="margin-bottom: 6px;">${f}</li>`).join('')}
              </ul>
            </div>
          ` : ''}
          
          <!-- Document Stats -->
          ${insights.document_stats ? `
            <div style="margin-bottom: 20px;">
              <h4 style="color: var(--vericase-teal); margin-bottom: 12px;"><i class="fas fa-chart-pie" style="margin-right: 8px;"></i>Document Statistics</h4>
              <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                <div style="background: rgba(31, 111, 120, 0.1); padding: 12px; border-radius: 8px; text-align: center;">
                  <div style="font-size: 1.5rem; font-weight: 700; color: var(--vericase-teal);">${insights.document_stats.total}</div>
                  <div style="font-size: 0.75rem; color: var(--text-muted);">Total Documents</div>
                </div>
                <div style="background: rgba(34, 197, 94, 0.1); padding: 12px; border-radius: 8px; text-align: center;">
                  <div style="font-size: 1.5rem; font-weight: 700; color: #22c55e;">${insights.document_stats.ai_analyzed}</div>
                  <div style="font-size: 0.75rem; color: var(--text-muted);">AI Analyzed</div>
                </div>
                <div style="background: rgba(139, 92, 246, 0.1); padding: 12px; border-radius: 8px; text-align: center;">
                  <div style="font-size: 1.5rem; font-weight: 700; color: #8b5cf6;">${insights.document_stats.high_confidence}</div>
                  <div style="font-size: 0.75rem; color: var(--text-muted);">High Confidence</div>
                </div>
              </div>
            </div>
          ` : ''}
          
          <!-- Top Stakeholders -->
          ${insights.stakeholders && insights.stakeholders.length > 0 ? `
            <div style="margin-bottom: 20px;">
              <h4 style="color: var(--vericase-teal); margin-bottom: 8px;"><i class="fas fa-users" style="margin-right: 8px;"></i>Key Stakeholders</h4>
              <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                ${insights.stakeholders.map(s => `
                  <span style="background: rgba(31, 111, 120, 0.15); color: var(--vericase-teal); padding: 4px 10px; border-radius: 12px; font-size: 0.85rem;">${s}</span>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <!-- Recommendations -->
          ${insights.recommendations && insights.recommendations.length > 0 ? `
            <div>
              <h4 style="color: #fbbf24; margin-bottom: 8px;"><i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>Recommendations</h4>
              <ul style="margin: 0; padding-left: 20px; color: var(--text-secondary);">
                ${insights.recommendations.map(r => `<li style="margin-bottom: 6px;">${r}</li>`).join('')}
              </ul>
            </div>
          ` : ''}
        </div>
      `;
      
      showChartPopup("Case Insights", content);
    }
    
    // Show chart in a popup modal
    function showChartPopup(title, content) {
      // Remove existing popup
      const existing = document.getElementById("chartPopup");
      if (existing) existing.remove();
      
      const popup = document.createElement("div");
      popup.id = "chartPopup";
      popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg-card);
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0,0,0,0.4);
        z-index: 10000;
        width: 600px;
        max-height: 80vh;
        overflow: auto;
      `;
      
      popup.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid var(--border-color);">
          <h3 style="margin: 0; font-size: 1.1rem;"><i class="fas fa-chart-bar" style="color: var(--vericase-teal); margin-right: 8px;"></i>${title}</h3>
          <button onclick="document.getElementById('chartPopup').remove()" style="background: transparent; border: none; color: var(--text-secondary); cursor: pointer; padding: 4px 8px; font-size: 1.2rem;">
            <i class="fas fa-times"></i>
          </button>
        </div>
        ${content}
      `;
      
      // Add backdrop
      const backdrop = document.createElement("div");
      backdrop.id = "chartBackdrop";
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.5);
        z-index: 9999;
      `;
      backdrop.onclick = () => {
        backdrop.remove();
        popup.remove();
      };
      
      document.body.appendChild(backdrop);
      document.body.appendChild(popup);
    }

    function refreshGridData() {
      if (!gridApi) return;
      gridApi.showLoadingOverlay();
      gridApi.refreshServerSideStore({ purge: true });
    }

    // Get selected evidence IDs for bulk operations
    function getSelectedEvidenceIds() {
      if (!gridApi) return [];
      const rows = gridApi.getSelectedRows();
      return rows.map(r => r.id).filter(Boolean);
    }

    // Mark selected evidence items as excluded
    async function markAsExcluded() {
      const ids = getSelectedEvidenceIds();
      if (!ids.length) {
        VericaseUI.Toast.info("Select one or more items first");
        return;
      }

      const ok = confirm(`Mark ${ids.length} item(s) as excluded?`);
      if (!ok) return;

      const reason = window.prompt("Reason (optional)", "");

      try {
        const response = await fetch(`${apiUrl}/api/evidence/items/bulk/exclude`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            evidence_ids: ids,
            project_id: currentProjectId || null,
            case_id: currentCaseId || null,
            excluded: true,
            reason: (reason || "").trim() || null,
          }),
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `HTTP ${response.status}`);
        }
        const data = await response.json();
        VericaseUI.Toast.success(`Excluded ${data?.updated ?? ids.length} item(s)`);
        refreshGridData();
      } catch (e) {
        console.error("Error excluding evidence:", e);
        VericaseUI.Toast.error("Failed to exclude items");
      }
    }

    // Delete selected evidence items
    async function deleteSelectedItems() {
      const ids = getSelectedEvidenceIds();
      if (!ids.length) {
        VericaseUI.Toast.info("Select one or more items first");
        return;
      }

      const ok = confirm(`Delete ${ids.length} item(s)? This action cannot be undone.`);
      if (!ok) return;

      try {
        const response = await fetch(`${apiUrl}/api/evidence/items/bulk/delete`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            evidence_ids: ids,
            project_id: currentProjectId || null,
            case_id: currentCaseId || null,
          }),
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || `HTTP ${response.status}`);
        }
        const data = await response.json();
        VericaseUI.Toast.success(`Deleted ${data?.deleted ?? ids.length} item(s)`);
        refreshGridData();
        loadStats();
      } catch (e) {
        console.error("Error deleting evidence:", e);
        VericaseUI.Toast.error("Failed to delete items");
      }
    }

    async function loadAllData() {
      // Prevent multiple simultaneous loads (fixes infinite loop)
      if (loadAllDataPromise) {
        console.log("[Evidence] loadAllData already running, skipping duplicate call");
        return loadAllDataPromise;
      }

      loadAllDataPromise = (async () => {
        try {
          const prefetched = getPrefetchedData();

          // Use prefetched collections/stats if available (for faster sidebar render)
          // Note: Dashboard only prefetches collections and stats, NOT items
          if (prefetched) {
            console.log(
              "[Evidence] Using prefetched collections/stats from dashboard",
            );

            // Render collections and stats immediately from cache
            if (prefetched.collections) {
              renderCollections(prefetched.collections);
            }
            if (prefetched.stats) {
              renderStats(prefetched.stats);
            }

            // Clear used cache
            sessionStorage.removeItem("vericase_evidence_prefetch");

            refreshGridData();
          } else {
            // Normal loading - fetch everything
            await Promise.all([loadCollections(), loadStats()]);
            refreshGridData();
          }
        } finally {
          loadAllDataPromise = null;
        }
      })();

      return loadAllDataPromise;
    }

    function applyFilters() {
      if (!gridApi) return;

      const filterModel = {};

      // Evidence tab is FILE evidence. Exclude correspondence (raw emails) from this grid.
      // Attachments can still have a source email (shown via origin/source email columns).
      filterModel["is_correspondence"] = false;

      // Category filter -> robust media filtering (mime type + extension fallback).
      // We intentionally don't rely on mime_type alone because many email attachments are stored
      // as application/octet-stream (which caused signatures/images to leak into Documents).
      console.log('[Category Debug] currentCategory:', currentCategory);
      if (currentCategory === "images") {
        filterModel["is_media"] = true;
        console.log('[Category Debug] Filtering for MEDIA (images/video/audio)');
      } else if (currentCategory === "documents") {
        filterModel["is_media"] = false;
        console.log('[Category Debug] Filtering for DOCUMENTS (non-media)');
      } else {
        console.log('[Category Debug] Showing ALL (no media filter)');
      }
      // "all" category doesn't add any media filter - show docs + images, but still excludes correspondence

      // Search filter -> filename contains
      const search = document
        .getElementById("searchInput")
        .value.toLowerCase()
        .trim();
      if (search) {
        filterModel["filename"] = {
          filterType: "text",
          type: "contains",
          filter: search,
        };
      }

      // File type filter
      const fileType = document.getElementById("fileTypeFilter").value;
      if (fileType) {
        const setValues = [];
        switch (fileType) {
          case "pdf":
            setValues.push("pdf");
            break;
          case "word":
            setValues.push("doc", "docx", "word");
            break;
          case "excel":
            setValues.push("xls", "xlsx", "csv", "spreadsheet");
            break;
          case "powerpoint":
            setValues.push("ppt", "pptx", "presentation");
            break;
          case "text":
            setValues.push("txt", "log", "md", "text");
            break;
          case "image":
            filterModel["is_image"] = true;
            break;
          case "other":
            // handled by server as no-op; rely on backend defaults
            break;
        }
        if (setValues.length > 0) {
          filterModel["file_type"] = {
            filterType: "set",
            values: setValues,
          };
        }
      }

      // Status filter
      const status = document.getElementById("statusFilter").value;
      if (status) {
        filterModel["processing_status"] = {
          filterType: "set",
          values: [status],
        };
      }

      // Unassigned filter
      if (document.getElementById("unassignedFilter").checked) {
        filterModel["unassigned"] = true;
      }

      // Starred filter
      if (document.getElementById("starredFilter").checked) {
        filterModel["is_starred"] = true;
      }

      serverSideFilterModel = filterModel;
      refreshGridData();
    }

    function createServerSideDatasource() {
      return {
        getRows: async (params) => {
          try {
            const activeCollection = document.querySelector(".collection-item.active");
            const collectionId = activeCollection?.dataset.id;
            const categoryFilter = activeCollection?.dataset.category;

            const query = new URLSearchParams();
            if (projectId) query.append("project_id", projectId);
            if (caseId) query.append("case_id", caseId);
            if (collectionId) query.append("collection_id", collectionId);
            if (categoryFilter) query.append("category", categoryFilter);
            query.append("include_email_info", "false");

            const body = {
              startRow: params.request.startRow ?? 0,
              endRow:
                params.request.endRow ??
                (params.request.startRow ?? 0) + (adminGridConfig.cacheBlockSize || 100),
              sortModel: params.request.sortModel || [],
              filterModel: {
                ...serverSideFilterModel,
                ...(params.request.filterModel || {}),
              },
            };

            const response = await fetch(
              `${apiUrl}/api/evidence/items/server-side?${query.toString()}`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
              },
            );

            if (response.ok) {
              const data = await response.json();
              params.success({
                rowData: data.rows || [],
                rowCount: data.lastRow ?? (data.rows ? data.rows.length : 0),
              });
              if (data.stats) {
                renderStats(data.stats);
                if (data.stats.total !== undefined) {
                  document.getElementById("docCount").textContent =
                    data.stats.total.toLocaleString();
                  document.getElementById("allCount").textContent =
                    data.stats.total.toLocaleString();
                  // Use image_count (includes all media - images, video, audio) for Images & Media tab
                  const mediaCount = data.stats.image_count ?? 
                    ((data.stats.by_type?.image || 0) + 
                     (data.stats.by_type?.video || 0) + 
                     (data.stats.by_type?.audio || 0));
                  document.getElementById("imgCount").textContent = mediaCount.toLocaleString?.() || mediaCount;
                }
              }
              if (gridApi) gridApi.hideOverlay();
            } else {
              const text = await response.text();
              console.error("[Evidence] Server-side load failed:", text);
              params.fail();
              VericaseUI.Toast.error("Failed to load evidence");
              if (gridApi) gridApi.showNoRowsOverlay();
            }
          } catch (error) {
            console.error("[Evidence] Server-side load error:", error);
            params.fail();
            VericaseUI.Toast.error("Failed to load evidence");
          }
        },
      };
    }

    // Render collections data (can be called with fetched or prefetched data)
    function renderCollections(collections) {
      const list = document.getElementById("collectionList");
      const collectionArray = Array.isArray(collections)
        ? collections
        : collections.collections || [];
      const seenNames = new Set(["all evidence"]);
      const filtered = [];
      collectionArray.forEach((c) => {
        const name = (c?.name || "").trim();
        if (!name) return;
        const key = name.toLowerCase();
        if (seenNames.has(key)) return;
        seenNames.add(key);
        filtered.push(c);
      });
      collectionsCache = filtered;

      // Default category folders that should always be shown
      const defaultCategories = [
        "Meeting Minutes",
        "Progress Reports",
        "Client Valuations",
        "Client Payment Certificates",
        "Change",
        "Subcontractor Valuations",
        "Subcontractor Payment Certificates",
        "Site Instructions",
        "Drawings",
        "Specifications"
      ];

      let html = `
                <div class="collection-item active" data-id="">
                    <i class="fas fa-folder"></i>
                    All Evidence
                </div>
            `;

      // Add default categories (create collection objects for any that don't exist yet)
      defaultCategories.forEach((catName) => {
        const existing = filtered.find(c => c.name?.toLowerCase() === catName.toLowerCase());
        if (!existing) {
          html += `
                    <div class="collection-item default-category" data-id="" data-category="${escapeHtml(catName)}">
                        <i class="fas fa-folder"></i>
                        ${escapeHtml(catName)}
                        <span class="collection-count">0</span>
                    </div>
                `;
        }
      });

      // Check if auto-categorize is enabled (load from saved config per project/case)
      const evidenceConfig = loadEvidenceConfig();
      const autoCategorize = evidenceConfig.autoCategorize || false;
      
      if (autoCategorize) {
        // Build hierarchy from parent_id relationships
        const collectionMap = new Map();
        const rootCollections = [];
        
        filtered.forEach((c) => {
          collectionMap.set(c.id, { ...c, children: [] });
        });
        
        filtered.forEach((c) => {
          if (c.parent_id && collectionMap.has(c.parent_id)) {
            collectionMap.get(c.parent_id).children.push(collectionMap.get(c.id));
          } else {
            rootCollections.push(collectionMap.get(c.id));
          }
        });
        
        // Render hierarchical structure
        function renderCollectionItem(collection, level = 0) {
          const icon = collection.is_system ? "fa-folder-open" : "fa-folder";
          const nestedClass = level > 0 ? ` nested${level > 3 ? "-3" : level > 2 ? "-2" : ""}` : "";
          let itemHtml = `
            <div class="collection-item${nestedClass}" data-id="${collection.id}">
                <i class="fas ${icon}"></i>
                ${escapeHtml(collection.name)}
                <span class="collection-count">${collection.item_count || 0}</span>
            </div>
          `;
          
          if (collection.children && collection.children.length > 0) {
            collection.children.forEach(child => {
              itemHtml += renderCollectionItem(child, level + 1);
            });
          }
          
          return itemHtml;
        }
        
        rootCollections.forEach(c => {
          html += renderCollectionItem(c);
        });
      } else {
        // Flat list (original behavior)
      filtered.forEach((c) => {
        const icon = c.is_system ? "fa-folder-open" : "fa-folder";
        html += `
                    <div class="collection-item" data-id="${c.id}">
                        <i class="fas ${icon}"></i>
                        ${escapeHtml(c.name)}
                        <span class="collection-count">${c.item_count || 0}</span>
                    </div>
                `;
      });
      }

      list.innerHTML = html;
      // Note: Click handler is attached via event delegation in DOMContentLoaded
    }

    async function loadCollections() {
      try {
        const params = new URLSearchParams();
        params.append("include_system", "true");
        if (projectId) params.append("project_id", projectId);
        if (caseId) params.append("case_id", caseId);

        const response = await fetch(`${apiUrl}/api/evidence/collections?${params.toString()}`);
        if (response.ok) {
          const collections = await response.json();
          renderCollections(collections);
        }
      } catch (error) {
        console.error("Error loading collections:", error);
      }
    }

    async function createSubfolder() {
      const name = prompt("Enter subfolder name:");
      if (!name || !name.trim()) return;

      const activeCollection = document.querySelector(".collection-item.active");
      const parentId = activeCollection?.dataset.id || null;

      try {
        const response = await fetch(`${apiUrl}/api/evidence/collections`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            name: name.trim(),
            parent_id: parentId || null,
            project_id: projectId || null,
            case_id: caseId || null,
          }),
        });

        if (response.ok) {
          VericaseUI.Toast.success("Subfolder created successfully");
          await loadCollections();
          if (selectedEvidence) {
            renderMetadata(selectedEvidence, null);
          }
        } else {
          const error = await response.json();
          VericaseUI.Toast.error(error.detail || "Failed to create subfolder");
        }
      } catch (error) {
        console.error("Error creating subfolder:", error);
        VericaseUI.Toast.error("Failed to create subfolder");
      }
    }

    // Render stats data (can be called with fetched or prefetched data)
    function renderStats(stats) {
      document.getElementById("totalCount").textContent = (
        stats.total || 0
      ).toLocaleString();
      document.getElementById("unassignedCount").textContent = (
        stats.unassigned || 0
      ).toLocaleString();
      document.getElementById("linkedCount").textContent = (
        stats.with_correspondence || 0
      ).toLocaleString();
      document.getElementById("recentCount").textContent = (
        stats.recent_uploads || 0
      ).toLocaleString();
      // Update category counters using stats if available
      const totalVal = stats.total || 0;
      document.getElementById("docCount").textContent = totalVal.toLocaleString();
      document.getElementById("allCount").textContent = totalVal.toLocaleString();
      const imgVal =
        stats.image_count ||
        (stats.by_type && (stats.by_type.image || stats.by_type.photo || 0)) ||
        0;
      document.getElementById("imgCount").textContent = imgVal.toLocaleString();
    }

    async function loadStats() {
      try {
        const params = new URLSearchParams();
        if (currentProjectId) params.append("project_id", currentProjectId);
        if (currentCaseId) params.append("case_id", currentCaseId);
        const url = `${apiUrl}/api/evidence/stats${params.toString() ? "?" + params.toString() : ""}`;
        const response = await fetch(url);
        if (response.ok) {
          const stats = await response.json();
          renderStats(stats);
        }
      } catch (error) {
        console.error("Error loading stats:", error);
      }
    }

    // ============================================
    // DETAIL PANEL
    // ============================================

    let detailLoadSeq = 0;
    const autoExtractAttemptedEvidenceIds = new Set();

    async function showDetail(evidence) {
      if (!evidence) return;

      const evidenceId = evidence.id;
      const loadSeq = ++detailLoadSeq;

      const panel = document.getElementById("detailPanel");
      panel.classList.add("open");

      // Show loading state
      document.getElementById("previewSection").innerHTML = `
                <div class="preview-placeholder">
                    <div class="loading" style="width: 32px; height: 32px; border-width: 3px;"></div>
                    <span>Loading preview...</span>
                </div>
            `;

      try {
        const fetchFull = async () => {
          const fullRes = await fetch(`${apiUrl}/api/evidence/items/${evidenceId}/full`);
          if (!fullRes.ok) {
            throw new Error(`Failed to load evidence full detail: ${fullRes.status}`);
          }
          const full = await fullRes.json();
          // Debug logging for S3 path troubleshooting
          if (full.preview && (full.preview._debug_s3_bucket || full.preview._debug_s3_key)) {
            console.log('[S3 Debug]', {
              bucket: full.preview._debug_s3_bucket,
              key: full.preview._debug_s3_key,
              previewUrl: full.preview.preview_url?.substring(0, 100) + '...',
              filename: full.detail?.filename
            });
          }
          return {
            detail: full.detail || {},
            preview: full.preview || null,
            metadata: full.metadata || null,
          };
        };

        let { detail, preview, metadata } = await fetchFull();

        const status = (detail.processing_status || "pending").toLowerCase();
        const previewUrlRequired =
          preview && ["image", "pdf", "audio", "video"].includes(preview.preview_type);
        const previewUrlMissing = !preview || (previewUrlRequired && !preview.preview_url);
        const shouldAutoExtract = status === "pending" || previewUrlMissing;

        if (
          shouldAutoExtract &&
          !autoExtractAttemptedEvidenceIds.has(String(evidenceId))
        ) {
          autoExtractAttemptedEvidenceIds.add(String(evidenceId));
          document.getElementById("previewSection").innerHTML = `
                <div class="preview-placeholder">
                    <div class="loading" style="width: 32px; height: 32px; border-width: 3px;"></div>
                    <span>Processing (OCR/metadata)...</span>
                </div>
            `;

          try {
            const extractRes = await fetch(
              `${apiUrl}/api/evidence/items/${evidenceId}/extract-metadata`,
              {
                method: "POST",
              },
            );

            if (extractRes.ok) {
              ({ detail, preview, metadata } = await fetchFull());
            } else {
              autoExtractAttemptedEvidenceIds.delete(String(evidenceId));
              console.error(
                "Auto-extract metadata failed:",
                extractRes.status,
                extractRes.statusText,
              );
            }
          } catch (error) {
            autoExtractAttemptedEvidenceIds.delete(String(evidenceId));
            console.error("Auto-extraction failed:", error);
          }
        }

        if (loadSeq !== detailLoadSeq) return;

        selectedEvidence = detail;
        currentPreviewData = preview;

        renderPreview(preview, detail);
        renderMetadata(detail, metadata);
        updateEvidenceLaneButtons();
        updateEvidenceNotePlaceholder();
        loadEvidenceNotes();
        await loadVeriCaseSuggestions(evidenceId, detail);
      } catch (error) {
        console.error("Error loading detail:", error);
        VericaseUI.Toast.error("Failed to load evidence details");
      }
    }

    function renderPreview(preview, detail) {
      const section = document.getElementById("previewSection");

      if (!preview) {
        section.innerHTML = `
                    <div class="preview-placeholder">
                        <i class="fas ${getFileIcon(detail.mime_type, detail.evidence_type)}"></i>
                        <span>Preview not available</span>
                    </div>
                `;
        return;
      }

      let html = "";

      switch (preview.preview_type) {
        case "image":
          html = `
                        <img src="${preview.preview_url}" alt="${detail.filename}" 
                             onerror="this.parentNode.innerHTML='<div class=\\'preview-placeholder\\'><i class=\\'fas fa-image\\'></i><span>Image not available</span><button class=\\'btn btn-vericase btn-sm\\' onclick=\\'downloadCurrentFile()\\' style=\\'margin-top:12px\\'><i class=\\'fas fa-download\\'></i> Download</button></div>'">
                        <button class="preview-expand-btn" onclick="openFullPreview()">
                            <i class="fas fa-expand"></i> Expand
                        </button>
                    `;
          break;

        case "pdf":
          // Use object tag for better error handling than iframe
          html = `
                        <object data="${preview.preview_url}#toolbar=0" type="application/pdf" style="width:100%;height:100%;min-height:400px;">
                            <div class="preview-placeholder">
                                <i class="fas fa-file-pdf"></i>
                                <span>PDF preview unavailable</span>
                                <p style="font-size:0.75rem;color:var(--text-muted);margin-top:8px;">Your browser may not support embedded PDFs</p>
                                <button class="btn btn-vericase btn-sm" onclick="downloadCurrentFile()" style="margin-top:12px">
                                    <i class="fas fa-download"></i> Download PDF
                                </button>
                            </div>
                        </object>
                        <button class="preview-expand-btn" onclick="openFullPreview()">
                            <i class="fas fa-expand"></i> Expand
                        </button>
                    `;
          break;

        case "audio":
          html = `
                        <audio controls src="${preview.preview_url}" style="width: 100%;"></audio>
                        <button class="preview-expand-btn" onclick="openFullPreview()">
                            <i class="fas fa-expand"></i> Expand
                        </button>
                    `;
          break;

        case "video":
          html = `
                        <video controls src="${preview.preview_url}" style="width: 100%; max-height: 100%;"></video>
                        <button class="preview-expand-btn" onclick="openFullPreview()">
                            <i class="fas fa-expand"></i> Expand
                        </button>
                    `;
          break;

        case "text":
        case "office":
          if (!preview.preview_content) {
            section.innerHTML = `
                        <div class="preview-placeholder">
                            <div class="loading" style="width: 32px; height: 32px; border-width: 3px;"></div>
                            <span>Loading text preview...</span>
                        </div>
                    `;

            fetch(
              `${apiUrl}/api/evidence/items/${detail.id}/text-content?max_length=100000`,
            )
              .then(async (response) =>
                response.ok ? response.json() : Promise.reject(response),
              )
              .then((data) => {
                if (!selectedEvidence || selectedEvidence.id !== detail.id) return;

                const contentStr =
                  typeof data.text === "string"
                    ? data.text
                    : JSON.stringify(data.text, null, 2);
                const truncated =
                  contentStr.length > 1000
                    ? contentStr.substring(0, 1000) + "\n..."
                    : contentStr;

                section.innerHTML = `
                        <pre style="color: var(--gray-400); font-size: 0.75rem; padding: 16px; margin: 0; overflow: auto; max-height: 100%;">${escapeHtml(truncated)}</pre>
                        <button class="preview-expand-btn" onclick="openFullPreview()">
                            <i class="fas fa-expand"></i> Full Text
                        </button>
                    `;
              })
              .catch((error) => {
                console.error("Error loading text content:", error);
                if (!selectedEvidence || selectedEvidence.id !== detail.id) return;

                section.innerHTML = `
                    <div class="preview-placeholder">
                        <i class="fas ${getFileIcon(detail.mime_type, detail.evidence_type)}"></i>
                        <span>Preview not available</span>
                    </div>
                `;
              });
            return;
          }

          const content = preview.preview_content || "No content available";
          const contentStr =
            typeof content === "string"
              ? content
              : JSON.stringify(content, null, 2);
          const truncated =
            contentStr.length > 1000
              ? contentStr.substring(0, 1000) + "\n..."
              : contentStr;
          html = `
                        <pre style="color: var(--gray-400); font-size: 0.75rem; padding: 16px; margin: 0; overflow: auto; max-height: 100%;">${escapeHtml(truncated)}</pre>
                        <button class="preview-expand-btn" onclick="openFullPreview()">
                            <i class="fas fa-expand"></i> Full Text
                        </button>
                    `;
          break;

        default:
          html = `
                        <div class="preview-placeholder">
                            <i class="fas ${getFileIcon(detail.mime_type, detail.evidence_type)}"></i>
                            <span>${detail.filename}</span>
                        </div>
                    `;
      }

      section.innerHTML = html;
    }

    function renderMetadata(detail, extractedMeta) {
      const content = document.getElementById("metadataContent");
      const meta = extractedMeta || detail.extracted_metadata || {};

      let html = "";

      const rawStatus = String(detail.processing_status || "pending").toLowerCase();
      const ocrCompleted = !!detail.ocr_completed;
      const hasMetadata =
        !!detail.page_count ||
        !!detail.author ||
        (Array.isArray(detail.extracted_parties) && detail.extracted_parties.length > 0) ||
        (Array.isArray(detail.auto_tags) && detail.auto_tags.length > 0);

      // Prefer truth signals: OCR completion beats status strings.
      let effectiveStatus = rawStatus;
      if (effectiveStatus === "completed") effectiveStatus = "ready";
      if (ocrCompleted) {
        effectiveStatus = "ready";
      } else if (effectiveStatus === "ready") {
        // Guard against incorrect backend status: ready without OCR completion.
        effectiveStatus = "processed";
      } else if (effectiveStatus === "pending" && hasMetadata) {
        effectiveStatus = "processed";
      }

      const statusLabel =
        effectiveStatus === "ready"
          ? "Complete (text extracted)"
          : effectiveStatus === "processed"
            ? "Processed (metadata only)"
            : effectiveStatus === "processing"
              ? "Processing..."
              : effectiveStatus === "pending"
                ? "Pending (not processed yet)"
                : effectiveStatus === "error"
                  ? "Error (processing failed)"
                  : effectiveStatus;

      // Basic Info
      html += `
                <div class="detail-section">
                    <div class="detail-section-header">
                        <i class="fas fa-info-circle"></i>
                        <h4>Basic Information</h4>
                    </div>
                    <div class="detail-item" style="margin-bottom: 12px;">
                        <div class="detail-label">Filename</div>
                        <div class="detail-value" style="word-break: break-all;">${escapeHtml(detail.filename)}</div>
                    </div>
                    ${detail.title && detail.title !== detail.filename
          ? `
                        <div class="detail-item" style="margin-bottom: 12px;">
                            <div class="detail-label">Title</div>
                            <div class="detail-value">${escapeHtml(detail.title)}</div>
                        </div>
                    `
          : ""
        }
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="detail-label">Type</div>
                            <div class="detail-value">${typeConfig[detail.evidence_type]?.label || detail.evidence_type || "Unknown"}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Size</div>
                            <div class="detail-value">${formatFileSize(detail.file_size)}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Status</div>
                            <div class="detail-value">
                                <span class="status-badge status-${effectiveStatus}">${statusLabel}</span>
                            </div>
                        </div>
                        ${detail.document_date
          ? `
                            <div class="detail-item">
                                <div class="detail-label">Document Date</div>
                                <div class="detail-value">${formatDate(detail.document_date)}</div>
                            </div>
                        `
          : ""
        }
                    </div>
                </div>
            `;

      // Document Properties
      if (meta.author || meta.created_date || meta.page_count) {
        html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-file-alt"></i>
                            <h4>Document Properties</h4>
                        </div>
                        <div class="detail-grid">
                            ${meta.author || detail.author
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Author</div>
                                    <div class="detail-value">${escapeHtml(meta.author || detail.author)}</div>
                                </div>
                            `
            : ""
          }
                            ${meta.page_count || detail.page_count
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Pages</div>
                                    <div class="detail-value">${meta.page_count || detail.page_count}</div>
                                </div>
                            `
            : ""
          }
                            ${meta.created_date
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Created</div>
                                    <div class="detail-value">${formatDate(meta.created_date)}</div>
                                </div>
                            `
            : ""
          }
                            ${meta.modified_date
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Modified</div>
                                    <div class="detail-value">${formatDate(meta.modified_date)}</div>
                                </div>
                            `
            : ""
          }
                        </div>
                    </div>
                `;
      }

      if (
        detail.source_email_subject ||
        detail.source_email_sender ||
        detail.source_email_date ||
        detail.source_email_preview ||
        detail.source_email_message_id ||
        detail.source_email_id
      ) {
        const toList = Array.isArray(detail.source_email_to)
          ? detail.source_email_to.join(", ")
          : detail.source_email_to || "";
        const ccList = Array.isArray(detail.source_email_cc)
          ? detail.source_email_cc.join(", ")
          : detail.source_email_cc || "";
        html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-envelope-open-text"></i>
                            <h4>Source Email</h4>
                        </div>
                        <div class="detail-grid">
                            ${detail.source_email_subject
                              ? `
                                <div class="detail-item" style="grid-column: 1 / -1;">
                                    <div class="detail-label">Subject</div>
                                    <div class="detail-value">${escapeHtml(detail.source_email_subject)}</div>
                                </div>
                            `
                              : ""
                            }
                            ${detail.source_email_sender
                              ? `
                                <div class="detail-item">
                                    <div class="detail-label">From</div>
                                    <div class="detail-value">${escapeHtml(detail.source_email_sender)}</div>
                                </div>
                            `
                              : ""
                            }
                            ${detail.source_email_date
                              ? `
                                <div class="detail-item">
                                    <div class="detail-label">Date</div>
                                    <div class="detail-value">${formatDate(detail.source_email_date)}</div>
                                </div>
                            `
                              : ""
                            }
                            ${toList
                              ? `
                                <div class="detail-item" style="grid-column: 1 / -1;">
                                    <div class="detail-label">To</div>
                                    <div class="detail-value">${escapeHtml(toList)}</div>
                                </div>
                            `
                              : ""
                            }
                            ${ccList
                              ? `
                                <div class="detail-item" style="grid-column: 1 / -1;">
                                    <div class="detail-label">Cc</div>
                                    <div class="detail-value">${escapeHtml(ccList)}</div>
                                </div>
                            `
                              : ""
                            }
                            ${detail.source_email_message_id
                              ? `
                                <div class="detail-item" style="grid-column: 1 / -1;">
                                    <div class="detail-label">Message ID</div>
                                    <div class="detail-value" style="word-break: break-all;">${escapeHtml(detail.source_email_message_id)}</div>
                                </div>
                            `
                              : ""
                            }
                            ${detail.source_email_id &&
                            detail.source_email_id !== detail.source_email_message_id
                              ? `
                                <div class="detail-item" style="grid-column: 1 / -1;">
                                    <div class="detail-label">Email ID</div>
                                    <div class="detail-value" style="word-break: break-all;">${escapeHtml(detail.source_email_id)}</div>
                                </div>
                            `
                              : ""
                            }
                        </div>
                        ${detail.source_email_preview
                          ? `
                            <div class="detail-item" style="margin-top: 12px;">
                                <div class="detail-label">Preview</div>
                                <div class="detail-value">${escapeHtml(detail.source_email_preview)}</div>
                            </div>
                        `
                          : ""
                        }
                    </div>
                `;
      }

      // Image EXIF
      if (meta.width || meta.camera_make || meta.date_taken) {
        html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-camera"></i>
                            <h4>Image Information</h4>
                        </div>
                        <div class="detail-grid">
                            ${meta.width && meta.height
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Dimensions</div>
                                    <div class="detail-value">${meta.width}  ${meta.height} px</div>
                                </div>
                            `
            : ""
          }
                            ${meta.camera_make
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Camera</div>
                                    <div class="detail-value">${escapeHtml(meta.camera_make)} ${escapeHtml(meta.camera_model || "")}</div>
                                </div>
                            `
            : ""
          }
                            ${meta.date_taken
            ? `
                                <div class="detail-item">
                                    <div class="detail-label">Date Taken</div>
                                    <div class="detail-value">${formatDate(meta.date_taken)}</div>
                                </div>
                            `
            : ""
          }
                        </div>
                        ${meta.gps_latitude && meta.gps_longitude
            ? `
                            <div class="detail-item" style="margin-top: 12px;">
                                <div class="detail-label">Location</div>
                                <a href="https://www.google.com/maps?q=${meta.gps_latitude},${meta.gps_longitude}" target="_blank" class="gps-map-link">
                                    <i class="fas fa-map-marker-alt"></i>
                                    ${meta.gps_latitude.toFixed(6)}, ${meta.gps_longitude.toFixed(6)}
                                    <i class="fas fa-external-link-alt" style="font-size: 0.6rem;"></i>
                                </a>
                            </div>
                        `
            : ""
          }
                    </div>
                `;
      }

      // Tags
      if (detail.auto_tags?.length > 0 || detail.manual_tags?.length > 0) {
        html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-tags"></i>
                            <h4>Tags</h4>
                        </div>
                        <div class="tag-list">
                            ${(detail.manual_tags || []).map((t) => `<span class="tag tag-teal">${escapeHtml(t)}</span>`).join("")}
                            ${(detail.auto_tags || []).map((t) => `<span class="tag">${escapeHtml(t)}</span>`).join("")}
                        </div>
                    </div>
                `;
      }

      // Filing
      const filingCollections = getFilingCollections();
      const filingOptionsHtml = filingCollections.length
        ? `<option value="">Select collection...</option>${filingCollections
            .map((c) => `<option value="${c.id}">${escapeHtml(c.name)}</option>`)
            .join("")}`
        : `<option value="">No collections yet  create one</option>`;
      const filingDisabled = filingCollections.length ? "" : "disabled";

      html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-folder-open"></i>
                            <h4>File Document</h4>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Collection</div>
                            <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                                <select id="collectionSelect" class="filter-select" style="flex: 1; min-width: 0;" ${filingDisabled}>
                                    ${filingOptionsHtml}
                                </select>
                                <button class="btn btn-vericase btn-sm" id="assignCollectionBtn" ${filingDisabled}>File</button>
                                <button class="btn btn-ghost btn-sm" id="autoFileBtn" ${filingDisabled}>Auto-file</button>
                                <button class="btn btn-ghost btn-sm" type="button" onclick="createSubfolder()">New folder</button>
                            </div>
                        </div>
                    </div>
                `;

      // Linked Correspondence
      if (detail.correspondence_links?.length > 0) {
        html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-envelope"></i>
                            <h4>Linked Correspondence (${detail.correspondence_links.length})</h4>
                        </div>
                        ${detail.correspondence_links
            .map(
              (link) => `
                            <div class="link-card">
                                ${link.email
                  ? `
                                    <div class="link-card-title">${escapeHtml(link.email.subject || "No subject")}</div>
                                    <div class="link-card-meta">${escapeHtml(link.email.sender || "")}  ${formatDate(link.email.date)}</div>
                                `
                  : ""
                }
                                <div class="link-card-meta">${link.link_type}  ${link.link_confidence ? link.link_confidence + "% confidence" : "Manual link"}</div>
                            </div>
                        `,
            )
            .join("")}
                    </div>
                `;
      }

      // Forensic Data
      if (detail.file_hash) {
        html += `
                    <div class="detail-section">
                        <div class="detail-section-header">
                            <i class="fas fa-fingerprint"></i>
                            <h4>Forensic Data</h4>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">SHA-256 Hash</div>
                            <div class="detail-value" style="font-family: var(--font-mono); font-size: 0.625rem; word-break: break-all;">${detail.file_hash}</div>
                        </div>
                        <div class="detail-item" style="margin-top: 8px;">
                            <div class="detail-label">Uploaded</div>
                            <div class="detail-value">${formatDate(detail.created_at)}</div>
                        </div>
                    </div>
                `;
      }

      content.innerHTML = html;
      setupCollectionActions();
    }

    function hideDetail() {
      document.getElementById("detailPanel").classList.remove("open");
      selectedEvidence = null;
      currentPreviewData = null;
      const thread = document.getElementById("evidenceCommentThread");
      if (thread) {
        thread.innerHTML = `<div class="collab-empty">Select an item to view notes.</div>`;
      }
      const input = document.getElementById("evidenceCommentInput");
      if (input) {
        input.value = "";
      }
      // Clear suggestions
      const suggestionsBody = document.getElementById("vericaseSuggestionsBody");
      if (suggestionsBody) {
        suggestionsBody.innerHTML = `
          <div class="suggestions-empty-state">
            <i class="fas fa-lightbulb"></i>
            <p>Select an evidence item to see AI-powered suggestions</p>
          </div>
        `;
      }
    }

    // ============================================
    // VERICASE SUGGESTIONS
    // ============================================

    async function loadVeriCaseSuggestions(evidenceId, detail) {
      const suggestionsBody = document.getElementById("vericaseSuggestionsBody");
      if (!suggestionsBody) return;

      // Show loading state
      suggestionsBody.innerHTML = `
        <div class="suggestions-loading">
          <div class="loading" style="width: 24px; height: 24px; border-width: 2px;"></div>
          <span>Loading suggestions...</span>
        </div>
      `;

      try {
        // Fetch suggestions from API
        const response = await fetch(`${apiUrl}/api/evidence/items/${evidenceId}/suggestions`);
        let suggestions = null;
        
        if (response.ok) {
          suggestions = await response.json();
        } else {
          // If API doesn't exist yet, generate suggestions from available data
          suggestions = generateSuggestionsFromDetail(detail);
        }

        renderVeriCaseSuggestions(suggestions, detail);
      } catch (error) {
        console.error("Error loading suggestions:", error);
        // Fallback to generating from detail data
        const suggestions = generateSuggestionsFromDetail(detail);
        renderVeriCaseSuggestions(suggestions, detail);
      }
    }

    function generateSuggestionsFromDetail(detail) {
      const suggestions = {
        link_suggestions: [],
        classification: null,
        extraction_status: {
          dates: detail.extracted_dates || [],
          parties: detail.extracted_parties || [],
          amounts: detail.extracted_amounts || [],
        },
        similar_items: [],
      };

      // Check if there's a source email - that's a link suggestion
      if (detail.source_email_id && detail.source_email_subject) {
        suggestions.link_suggestions.push({
          email_id: detail.source_email_id,
          email_subject: detail.source_email_subject,
          email_sender: detail.source_email_sender,
          email_date: detail.source_email_date,
          link_type: "Email Attachment",
          confidence: 100,
          method: "Direct attachment",
        });
      }

      // Suggest collection based on evidence type
      if (detail.evidence_type) {
        const typeToCollection = {
          drawing: "Drawings",
          photo: "Photos",
          document: "Documents",
        };
        const suggestedCollection = typeToCollection[detail.evidence_type];
        if (suggestedCollection) {
          suggestions.classification = {
            collection_name: suggestedCollection,
            confidence: 75,
            reason: `Based on evidence type: ${detail.evidence_type}`,
          };
        }
      }

      return suggestions;
    }

    function renderVeriCaseSuggestions(suggestions, detail) {
      const suggestionsBody = document.getElementById("vericaseSuggestionsBody");
      if (!suggestionsBody) return;

      let html = "";

      // Link Suggestions
      if (suggestions.link_suggestions && suggestions.link_suggestions.length > 0) {
        html += `
          <div class="suggestion-group">
            <div class="suggestion-group-header">
              <i class="fas fa-link"></i>
              <span>Link Suggestions</span>
            </div>
            <div class="suggestion-list">
              ${suggestions.link_suggestions.map(link => `
                <div class="suggestion-item suggestion-link">
                  <div class="suggestion-item-content">
                    <div class="suggestion-item-title">
                      <i class="fas fa-envelope"></i>
                      ${escapeHtml(link.email_subject || "Email")}
                    </div>
                    <div class="suggestion-item-meta">
                      ${link.email_sender ? escapeHtml(link.email_sender) : ""}
                      ${link.email_date ? `  ${formatDate(link.email_date)}` : ""}
                      ${link.confidence ? `  ${link.confidence}% confidence` : ""}
                    </div>
                    ${link.context ? `<div class="suggestion-item-context">${escapeHtml(link.context)}</div>` : ""}
                  </div>
                  ${link.email_id ? `
                    <button class="btn btn-sm btn-ghost" onclick="openSourceEmail('${link.email_id}')" title="View email">
                      <i class="fas fa-external-link-alt"></i>
                    </button>
                  ` : ""}
                </div>
              `).join("")}
            </div>
          </div>
        `;
      }

      // Classification Suggestion
      if (suggestions.classification) {
        html += `
          <div class="suggestion-group">
            <div class="suggestion-group-header">
              <i class="fas fa-folder"></i>
              <span>Suggested Collection</span>
            </div>
            <div class="suggestion-item suggestion-classification">
              <div class="suggestion-item-content">
                <div class="suggestion-item-title">
                  <i class="fas fa-folder-open"></i>
                  ${escapeHtml(suggestions.classification.collection_name)}
                </div>
                ${suggestions.classification.reason ? `
                  <div class="suggestion-item-context">${escapeHtml(suggestions.classification.reason)}</div>
                ` : ""}
                ${suggestions.classification.confidence ? `
                  <div class="suggestion-item-meta">${suggestions.classification.confidence}% confidence</div>
                ` : ""}
              </div>
            </div>
          </div>
        `;
      }

      // Extraction Status
      const extraction = suggestions.extraction_status || {};
      const hasExtractions = (extraction.dates && extraction.dates.length > 0) ||
                            (extraction.parties && extraction.parties.length > 0) ||
                            (extraction.amounts && extraction.amounts.length > 0);
      
      if (hasExtractions) {
        html += `
          <div class="suggestion-group">
            <div class="suggestion-group-header">
              <i class="fas fa-check-circle"></i>
              <span>Extracted Metadata</span>
            </div>
            <div class="suggestion-item suggestion-extraction">
              <div class="suggestion-item-content">
                ${extraction.dates && extraction.dates.length > 0 ? `
                  <div class="suggestion-item-meta">
                    <i class="fas fa-calendar"></i>
                    <strong>Dates:</strong> ${extraction.dates.slice(0, 3).map(d => escapeHtml(String(d))).join(", ")}
                    ${extraction.dates.length > 3 ? ` +${extraction.dates.length - 3} more` : ""}
                  </div>
                ` : ""}
                ${extraction.parties && extraction.parties.length > 0 ? `
                  <div class="suggestion-item-meta">
                    <i class="fas fa-id-badge"></i>
                    <strong>Stakeholders:</strong> ${extraction.parties.slice(0, 3).map(p => escapeHtml(String(p))).join(", ")}
                    ${extraction.parties.length > 3 ? ` +${extraction.parties.length - 3} more` : ""}
                  </div>
                ` : ""}
                ${extraction.amounts && extraction.amounts.length > 0 ? `
                  <div class="suggestion-item-meta">
                    <i class="fas fa-pound-sign"></i>
                    <strong>Amounts:</strong> ${extraction.amounts.slice(0, 3).map(a => escapeHtml(String(a))).join(", ")}
                    ${extraction.amounts.length > 3 ? ` +${extraction.amounts.length - 3} more` : ""}
                  </div>
                ` : ""}
              </div>
            </div>
          </div>
        `;
      }

      // Similar Items
      if (suggestions.similar_items && suggestions.similar_items.length > 0) {
        html += `
          <div class="suggestion-group">
            <div class="suggestion-group-header">
              <i class="fas fa-copy"></i>
              <span>Similar Items</span>
            </div>
            <div class="suggestion-list">
              ${suggestions.similar_items.map(item => `
                <div class="suggestion-item suggestion-similar">
                  <div class="suggestion-item-content">
                    <div class="suggestion-item-title">${escapeHtml(item.filename || "Unknown")}</div>
                    <div class="suggestion-item-meta">${item.similarity ? `${item.similarity}% similar` : ""}</div>
                  </div>
                </div>
              `).join("")}
            </div>
          </div>
        `;
      }

      if (!html) {
        html = `
          <div class="suggestions-empty-state">
            <i class="fas fa-lightbulb"></i>
            <p>No suggestions available for this item</p>
          </div>
        `;
      }

      suggestionsBody.innerHTML = html;
    }

    // ============================================
    // ACTIONS
    // ============================================

    function openSourceEmail(emailId) {
      // Navigate to correspondence page with the specific email highlighted
      if (emailId && projectId) {
        window.location.href = `correspondence-enterprise.html?projectId=${projectId}&emailId=${emailId}`;
      } else if (emailId && caseId) {
        window.location.href = `correspondence-enterprise.html?caseId=${caseId}&emailId=${emailId}`;
      } else if (emailId) {
        VericaseUI.Toast.info('Opening email viewer...');
        // Could also open in a modal or panel
        window.open(`/api/correspondence/${emailId}`, "_blank");
      }
    }

    async function toggleStar(evidenceId) {
      try {
        const response = await fetch(
          `${apiUrl}/api/evidence/items/${evidenceId}/star`,
          {
            method: "POST",
          },
        );

        if (response.ok) {
          const result = await response.json();
          refreshGridData();
          VericaseUI.Toast.success(
            result.is_starred ? "Added to starred" : "Removed from starred",
          );
        }
      } catch (error) {
        console.error("Error toggling star:", error);
        VericaseUI.Toast.error("Failed to update star status");
      }
    }

    function downloadCurrentFile() {
      if (currentPreviewData?.download_url) {
        window.open(currentPreviewData.download_url, "_blank");
      } else if (selectedEvidence?.download_url) {
        window.open(selectedEvidence.download_url, "_blank");
      }
    }

    async function openFullPreview() {
      if (!selectedEvidence || !currentPreviewData) return;

      const modal = document.getElementById("previewModal");
      const content = document.getElementById("previewModalContent");
      const title = document.getElementById("previewModalTitle");

      title.textContent = selectedEvidence.filename;

      let html = "";
      let officeSrcdoc = null;

      switch (currentPreviewData.preview_type) {
        case "image":
          html = `<img src="${currentPreviewData.preview_url}" alt="${selectedEvidence.filename}" 
                   onerror="this.parentNode.innerHTML='<div style=\\'text-align:center;color:var(--gray-400);padding:40px\\'><i class=\\'fas fa-image\\' style=\\'font-size:4rem;margin-bottom:1rem\\'></i><p>Image not available</p><button class=\\'btn btn-vericase\\' style=\\'margin-top:1rem\\' onclick=\\'downloadCurrentFile()\\'><i class=\\'fas fa-download\\'></i> Download</button></div>'">`;
          break;

        case "pdf":
          html = `<object data="${currentPreviewData.preview_url}" type="application/pdf" style="width:90vw;height:calc(100vh - 150px);">
                    <div style="text-align:center;color:var(--gray-400);padding:40px">
                      <i class="fas fa-file-pdf" style="font-size:4rem;margin-bottom:1rem"></i>
                      <p>PDF preview unavailable</p>
                      <button class="btn btn-vericase" style="margin-top:1rem" onclick="downloadCurrentFile()">
                        <i class="fas fa-download"></i> Download PDF
                      </button>
                    </div>
                  </object>`;
          break;

        case "audio":
          html = `<audio controls src="${currentPreviewData.preview_url}" style="width: 100%;"></audio>`;
          break;

        case "video":
          html = `<video controls src="${currentPreviewData.preview_url}" style="width: 100%; max-height: 80vh;"></video>`;
          break;

        case "text":
        case "office":
          if (currentPreviewData.preview_type === "office") {
            try {
              const resp = await fetch(
                `${apiUrl}/api/evidence/items/${selectedEvidence.id}/office-render?max_rows=200&max_cols=40`,
              );
              if (resp.ok) {
                const data = await resp.json();
                if (data && typeof data.html === "string" && data.html.trim()) {
                  officeSrcdoc = data.html;
                  html = `
                    <div style="width: 90vw; height: calc(100vh - 150px); background: white; border-radius: 12px; overflow: hidden; border: 1px solid rgba(15,23,42,0.08);">
                      <iframe id="officePreviewFrame" title="${escapeHtml(selectedEvidence.filename)}"
                              style="width:100%; height:100%; border:0; background:white;"
                              sandbox="allow-same-origin"></iframe>
                    </div>
                  `;
                  break;
                }
              }
            } catch (e) {
              console.warn("Office render preview failed, falling back to text:", e);
            }
          }

          try {
            const response = await fetch(
              `${apiUrl}/api/evidence/items/${selectedEvidence.id}/text-content?max_length=100000`,
            );
            if (response.ok) {
              const data = await response.json();
              html = `<pre>${escapeHtml(data.text)}</pre>`;
            } else {
              html = `<pre>${escapeHtml(currentPreviewData.preview_content || "Could not load text content")}</pre>`;
            }
          } catch {
            html = `<pre>${escapeHtml(currentPreviewData.preview_content || "Could not load text content")}</pre>`;
          }
          break;

        default:
          html = `
                        <div style="text-align: center; color: var(--gray-400);">
                            <i class="fas ${getFileIcon(selectedEvidence.mime_type, selectedEvidence.evidence_type)}" style="font-size: 4rem; margin-bottom: 1rem;"></i>
                            <p>Preview not available for this file type</p>
                            <p style="font-size: 0.875rem; margin-top: 0.5rem;">${escapeHtml(selectedEvidence.filename)}</p>
                            <button class="btn btn-vericase" style="margin-top: 1rem;" onclick="downloadCurrentFile()">
                                <i class="fas fa-download"></i> Download File
                            </button>
                        </div>
                    `;
      }

      content.innerHTML = html;
      if (officeSrcdoc) {
        const frame = document.getElementById("officePreviewFrame");
        if (frame) frame.srcdoc = officeSrcdoc;
      }
      modal.classList.add("active");
    }

    function closePreviewModal() {
      document.getElementById("previewModal").classList.remove("active");
    }

    async function extractMetadata() {
      if (!selectedEvidence) return;

      const btn = document.getElementById("extractMetadataBtn");
      btn.disabled = true;
      btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

      try {
        const response = await fetch(
          `${apiUrl}/api/evidence/items/${selectedEvidence.id}/extract-metadata`,
          {
            method: "POST",
          },
        );

        if (response.ok) {
          await showDetail(selectedEvidence);
          VericaseUI.Toast.success("Metadata extracted successfully");
        } else {
          VericaseUI.Toast.error("Failed to extract metadata");
        }
      } catch (error) {
        console.error("Error extracting metadata:", error);
        VericaseUI.Toast.error("Failed to extract metadata");
      } finally {
        btn.disabled = false;
        btn.innerHTML = '<i class="fas fa-magnifying-glass"></i>';
      }
    }

    function getActiveCollectionId() {
      const active = document.querySelector(".collection-item.active");
      const id = (active?.dataset?.id || "").trim();
      return id ? id : null;
    }

    function setActiveCollectionById(collectionId) {
      if (!collectionId) return false;
      const list = document.getElementById("collectionList");
      if (!list) return false;
      const target = list.querySelector(`.collection-item[data-id="${collectionId}"]`);
      if (!target) return false;
      list.querySelectorAll(".collection-item").forEach((i) => i.classList.remove("active"));
      target.classList.add("active");
      return true;
    }

    function getRootFolderNameFromFiles(fileList) {
      if (!fileList || fileList.length === 0) return null;
      for (const f of fileList) {
        const rel = f.webkitRelativePath || "";
        if (rel) return rel.split("/")[0] || null;
      }
      return null;
    }

    function findExistingCollectionByName(name, parentId) {
      const wanted = (name || "").trim().toLowerCase();
      const pid = parentId || null;
      if (!wanted) return null;
      return (collectionsCache || []).find((c) => {
        const cname = (c?.name || "").trim().toLowerCase();
        const cpid = c?.parent_id || null;
        return cname === wanted && cpid === pid;
      }) || null;
    }

    async function ensureFolderCollection(folderName, parentId) {
      const trimmed = (folderName || "").trim();
      if (!trimmed) return null;

      const existing = findExistingCollectionByName(trimmed, parentId);
      if (existing?.id) return existing.id;

      try {
        const response = await fetch(`${apiUrl}/api/evidence/collections`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            name: trimmed,
            description: `Uploaded folder: ${trimmed}`,
            parent_id: parentId || null,
            project_id: projectId || null,
            case_id: caseId || null,
          }),
        });

        if (response.ok) {
          const created = await response.json();
          return created?.id || null;
        }
      } catch (e) {
        console.warn("Failed to create folder collection:", e);
      }

      // Fallback: reload collections and try to find it again (in case it already exists).
      try {
        await loadCollections();
        const existing2 = findExistingCollectionByName(trimmed, parentId);
        return existing2?.id || null;
      } catch (_) {
        return null;
      }
    }

    async function handleFolderUpload(event) {
      const files = event.target.files;
      if (!files || files.length === 0) return;

      const uploadBtn = document.getElementById("uploadBtn");
      const uploadFolderBtn = document.getElementById("uploadFolderBtn");
      uploadBtn.disabled = true;
      uploadBtn.classList.add("loading");
      if (uploadFolderBtn) {
        uploadFolderBtn.disabled = true;
        uploadFolderBtn.classList.add("loading");
      }

      const rootFolder = getRootFolderNameFromFiles(files) || "Uploaded Folder";
      const parentId = getActiveCollectionId(); // If a real collection is selected, create as subfolder.

      const toast = VericaseUI.Toast.info(
        `Uploading folder "${rootFolder}" (${files.length} file(s))...`,
        { duration: 0 },
      );

      try {
        const collectionId = await ensureFolderCollection(rootFolder, parentId);
        if (!collectionId) {
          throw new Error("Could not create or find a collection for this folder");
        }

        let successCount = 0;
        for (const file of files) {
          const formData = new FormData();
          formData.append("file", file);
          if (projectId) formData.append("project_id", projectId);
          if (caseId) formData.append("case_id", caseId);
          formData.append("collection_id", collectionId);
          const rel = file.webkitRelativePath || "";
          if (rel) formData.append("original_path", rel);

          const response = await fetch(`${apiUrl}/api/evidence/upload/direct`, {
            method: "POST",
            body: formData,
          });

          if (response.ok) successCount++;
        }

        VericaseUI.Toast.dismiss(toast);
        VericaseUI.Toast.success(
          `Uploaded ${successCount}/${files.length} file(s) to "${rootFolder}"`,
        );

        await loadCollections();
        setActiveCollectionById(collectionId);
        refreshGridData();
        loadStats();
      } catch (error) {
        console.error("Folder upload error:", error);
        VericaseUI.Toast.dismiss(toast);
        VericaseUI.Toast.error("Folder upload failed. Please try again.");
      } finally {
        uploadBtn.disabled = false;
        uploadBtn.classList.remove("loading");
        if (uploadFolderBtn) {
          uploadFolderBtn.disabled = false;
          uploadFolderBtn.classList.remove("loading");
        }
        document.getElementById("folderInput").value = "";
      }
    }

    async function handleFileUpload(event) {
      const files = event.target.files;
      if (!files || files.length === 0) return;

      const uploadBtn = document.getElementById("uploadBtn");
      uploadBtn.disabled = true;
      uploadBtn.classList.add("loading");

      const toast = VericaseUI.Toast.info(
        `Uploading ${files.length} file(s)...`,
        { duration: 0 },
      );

      try {
        const activeCollectionId = getActiveCollectionId();
        let successCount = 0;
        for (const file of files) {
          const formData = new FormData();
          formData.append("file", file);
          if (projectId) formData.append("project_id", projectId);
          if (caseId) formData.append("case_id", caseId);
          if (activeCollectionId) formData.append("collection_id", activeCollectionId);
          const rel = file.webkitRelativePath || "";
          if (rel) formData.append("original_path", rel);

          const response = await fetch(
            `${apiUrl}/api/evidence/upload/direct`,
            {
              method: "POST",
              body: formData,
            },
          );

          if (response.ok) successCount++;
        }

        VericaseUI.Toast.dismiss(toast);
        VericaseUI.Toast.success(
          `Successfully uploaded ${successCount} file(s)`,
        );

        if (activeCollectionId) {
          await loadCollections();
          setActiveCollectionById(activeCollectionId);
        }
        refreshGridData();
        loadStats();
      } catch (error) {
        console.error("Upload error:", error);
        VericaseUI.Toast.dismiss(toast);
        VericaseUI.Toast.error("Upload failed. Please try again.");
      } finally {
        uploadBtn.disabled = false;
        uploadBtn.classList.remove("loading");
        document.getElementById("fileInput").value = "";
      }
    }

    async function rescanKeywords() {
      const btn = document.getElementById("rescanKeywordsBtn");
      if (!btn) return;

      const endpoint =
        projectId
          ? `${apiUrl}/api/projects/${encodeURIComponent(projectId)}/keywords/rescan`
          : caseId
            ? `${apiUrl}/api/cases/${encodeURIComponent(caseId)}/keywords/rescan`
            : null;

      if (!endpoint) {
        VericaseUI.Toast.error("No project/case context to rescan keywords.");
        return;
      }

      const originalHtml = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span class="btn-text-sm">Rescanning</span>';

      const toast = VericaseUI.Toast.info("Rescanning keywords across correspondence + evidence", {
        duration: 0,
      });

      try {
        const resp = await fetch(endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            include_emails: true,
            include_evidence: true,
            max_emails: 20000,
            max_evidence: 20000,
            mode: "overwrite",
          }),
        });

        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          const msg = data?.detail || `Keyword rescan failed (HTTP ${resp.status})`;
          throw new Error(msg);
        }

        const emailsUpdated = Number(data.emails_updated || 0);
        const evidenceUpdated = Number(data.evidence_updated || 0);
        const keywordsCount = Number(data.keywords || 0);
        VericaseUI.Toast.dismiss(toast);
        VericaseUI.Toast.success(
          `Keyword rescan complete (${keywordsCount} keywords): ${emailsUpdated} emails updated, ${evidenceUpdated} evidence items updated.`,
        );

        // Evidence grid doesn't show keyword columns yet, but refresh keeps things consistent.
        refreshGridData();
        loadStats();
      } catch (e) {
        console.error("Keyword rescan failed:", e);
        VericaseUI.Toast.dismiss(toast);
        VericaseUI.Toast.error("Keyword rescan failed. Please try again.");
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalHtml;
      }
    }

    // ============================================
    // EVENT LISTENERS
    // ============================================

    document.addEventListener("DOMContentLoaded", async () => {
      // Get context (project or case)
      const ctx =
        typeof VericaseShell.getContext === "function"
          ? VericaseShell.getContext()
          : { type: "project", id: VericaseShell.getProjectId() };
      const ctxType = ctx?.type === "case" ? "case" : "project";
      const ctxLabel =
        ctxType === "case" ? "Case Overview" : "Project Overview";
      const ctxIcon = ctxType === "case" ? "fa-briefcase" : "fa-diagram-project";
      const ctxId = ctx?.id ? String(ctx.id) : "";
      const ctxUrl = ctxId
        ? `projectdashboard.html?${ctxType === "case" ? "caseId" : "projectId"}=${encodeURIComponent(ctxId)}`
        : "projectdashboard.html";

      // Inject navigation shell
      VericaseShell.inject({
        title: '',
        breadcrumbs: [
          { label: "Control Centre", url: "control-centre.html", icon: "fa-compass" },
          { label: "Workspaces", url: "workspace-hub.html", icon: "fa-layer-group" },
          { label: ctxLabel, url: ctxUrl, icon: ctxIcon },
          { label: "Evidence & Files", icon: "fa-folder-tree" },
        ],
        headerActions: "",
        contentClass: "app-content--flush evidence-page",
      });

      if (ctx.type === "case") {
        caseId = ctx.id;
        projectId = "";
      } else {
        projectId = ctx.id;
        caseId = "";
      }

      // Initialize grid with admin config
      await initGrid();

      // Setup AI Intelligence Panel
      setupAIIntelligenceButton();
      
      // Setup Charts dropdown
      setupChartsDropdown();

      // Apply initial filters for default category
      applyFilters();

      // Load data after grid is ready
      loadAllData();

      // Category tabs
      document.querySelectorAll(".category-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          document
            .querySelectorAll(".category-tab")
            .forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          currentCategory = tab.dataset.category;
          applyFilters();
        });
      });

      // Load and apply saved evidence configuration
      const evidenceConfig = loadEvidenceConfig();
      const autoCategorizeToggle = document.getElementById("autoCategorizeToggle");
      if (autoCategorizeToggle) {
        autoCategorizeToggle.checked = evidenceConfig.autoCategorize || false;
      }

      // Auto-categorize toggle - save per project/case and run categorization
      document.getElementById("autoCategorizeToggle").addEventListener("change", (e) => {
        const config = loadEvidenceConfig();
        config.autoCategorize = e.target.checked;
        saveEvidenceConfig(config);

        // Re-render collections with hierarchy if enabled
        if (collectionsCache.length > 0) {
          renderCollections(collectionsCache);
        }

        // Run auto-categorization when enabled
        if (e.target.checked) {
          const confirmed = confirm(
            "Auto-categorize will analyze uncategorized evidence items and assign categories based on filename patterns.\n\nDo you want to run auto-categorization now?"
          );
          if (confirmed) {
            runAutoCategorization();
          }
        }
      });

      // Create subfolder button
      document.getElementById("createSubfolderBtn").addEventListener("click", () => {
        createSubfolder();
      });

      // Collection list - use event delegation to avoid listener accumulation
      document.getElementById("collectionList").addEventListener("click", (e) => {
        const item = e.target.closest(".collection-item");
        if (item) {
          const list = document.getElementById("collectionList");
          list.querySelectorAll(".collection-item")
            .forEach((i) => i.classList.remove("active"));
          item.classList.add("active");
          refreshGridData();
        }
      });

      // Search with debounce
      let searchTimeout;
      document.getElementById("searchInput").addEventListener("input", () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(applyFilters, 300);
      });

      // Filters
      document
        .getElementById("fileTypeFilter")
        .addEventListener("change", applyFilters);
      document
        .getElementById("statusFilter")
        .addEventListener("change", applyFilters);

      // Checkbox pills
      document
        .getElementById("unassignedFilter")
        .addEventListener("change", (e) => {
          document
            .getElementById("unassignedPill")
            .classList.toggle("active", e.target.checked);
          applyFilters();
        });

      document
        .getElementById("starredFilter")
        .addEventListener("change", (e) => {
          document
            .getElementById("starredPill")
            .classList.toggle("active", e.target.checked);
          applyFilters();
        });

      // Upload
      document.getElementById("uploadBtn").addEventListener("click", () => {
        document.getElementById("fileInput").click();
      });
      document
        .getElementById("fileInput")
        .addEventListener("change", handleFileUpload);
      document.getElementById("uploadFolderBtn").addEventListener("click", () => {
        document.getElementById("folderInput").click();
      });
      document
        .getElementById("folderInput")
        .addEventListener("change", handleFolderUpload);
      document.getElementById("rescanKeywordsBtn").addEventListener("click", () => {
        void rescanKeywords();
      });

      // Refresh
      document.getElementById("refreshBtn").addEventListener("click", () => {
        VericaseUI.Toast.info("Refreshing...");
        loadAllData();
      });

      document.getElementById("columnsBtn").addEventListener("click", () => {
        toggleColumnsPanel();
      });

      document.getElementById("saveGridBtn").addEventListener("click", () => {
        saveGridState();
      });

      document.getElementById("resetGridBtn").addEventListener("click", () => {
        resetGridState();
      });

      document.getElementById("autofitBtn").addEventListener("click", () => {
        autoFitGrid(true);
      });
      // Detail panel
      document
        .getElementById("closeDetailBtn")
        .addEventListener("click", hideDetail);
      document
        .getElementById("viewItemBtn")
        .addEventListener("click", openFullPreview);
      document
        .getElementById("downloadBtn")
        .addEventListener("click", downloadCurrentFile);
      document
        .getElementById("previewFullBtn")
        .addEventListener("click", openFullPreview);
      document
        .getElementById("extractMetadataBtn")
        .addEventListener("click", extractMetadata);

      // Preview modal
      document
        .getElementById("closePreviewModal")
        .addEventListener("click", closePreviewModal);
      document
        .getElementById("modalDownloadBtn")
        .addEventListener("click", downloadCurrentFile);
      // Close modal when clicking outside the content (on the modal backdrop or body)
      document
        .getElementById("previewModal")
        .addEventListener("click", (e) => {
          const content = document.getElementById("previewModalContent");
          const header = document.querySelector(".preview-modal-header");
          // Close if clicking on the modal overlay itself (not on content or header)
          if (!content.contains(e.target) && !header.contains(e.target)) {
            closePreviewModal();
          }
        });

      // Escape key to close panels
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          hideDetail();
          closePreviewModal();
        }
      });
      // Remove preload class after initial render
      requestAnimationFrame(() => {
        document.body.classList.remove("preload");
      });
    });
  </script>
</body>

</html>
